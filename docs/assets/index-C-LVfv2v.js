import{B as mn,y as wn,z as Je,D as bn,F as vn,G as X,J as be,m as Kt,K as D,L as Cn,P as R,Q as Yt,V as Nt,X as In,Y as jr,Z as En,$ as Jt,a0 as Sn,a1 as zr,a2 as Gr,a3 as Bt,a4 as jt,a5 as ft,k as Pt,a6 as Wr,h as bt,a7 as _t,a8 as Xt,a9 as qt,aa as Bn,ab as Qt,ac as ke,ad as Zr,ae as U,af as Vr,ag as Kr,ah as Ne,ai as Yr,aj as Pe,ak as Jr,al as qe,am as Xr,an as Qr,_ as ts,ao as es,ap as ns,l as _n,i as rs,I as ss,aq as os,ar as ve,as as xn,at as is,au as cs,av as te,n as Ce,aw as Xe,ax as An,ay as as,az as us,aA as ds,aB as zt,aC as ls,aD as Tn,aE as kn,aF as Nn,aG as $e,aH as Pn,aI as qn,aJ as $n,aK as Fn,aL as Rn,aM as On,aN as Dn,aO as Ln,aP as Mn,aQ as Un,aR as Fe,aS as Hn,aT as Re,aU as fs,aV as tt,aW as jn,aX as hs,aY as gs,aZ as ps,a_ as zn,a$ as Gn,b0 as ys,b1 as Lt,b2 as Wn,b3 as Zn,b4 as ms,b5 as dt,b6 as St,b7 as Gt,b8 as Ie,b9 as Ee,ba as Vn,bb as ae,bc as Qe,bd as ws,be as tn,bf as bs}from"./index-B5jhtYOO.js";import{bg as Zc}from"./index-B5jhtYOO.js";import{i as vs}from"./isAddressEqual-CLBb2OX3.js";class Cs extends mn{constructor(e){super(`Filter type "${e}" is not supported.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"FilterTypeNotSupportedError"})}}const en="/docs/contract/encodeEventTopics";function $t(t){var a;const{abi:e,eventName:n,args:r}=t;let s=e[0];if(n){const u=wn({abi:e,name:n});if(!u)throw new Je(n,{docsPath:en});s=u}if(s.type!=="event")throw new Je(void 0,{docsPath:en});const o=bn(s),i=vn(o);let c=[];if(r&&"inputs"in s){const u=(a=s.inputs)==null?void 0:a.filter(d=>"indexed"in d&&d.indexed),l=Array.isArray(r)?r:Object.values(r).length>0?(u==null?void 0:u.map(d=>r[d.name]))??[]:[];l.length>0&&(c=(u==null?void 0:u.map((d,g)=>Array.isArray(l[g])?l[g].map((I,w)=>nn({param:d,value:l[g][w]})):l[g]?nn({param:d,value:l[g]}):null))??[])}return[i,...c]}function nn({param:t,value:e}){if(t.type==="string"||t.type==="bytes")return X(be(e));if(t.type==="tuple"||t.type.match(/^(.*)\[(\d+)?\]$/))throw new Cs(t.type);return Kt([t],[e])}function ee(t,{method:e}){var r,s;const n={};return t.transport.type==="fallback"&&((s=(r=t.transport).onResponse)==null||s.call(r,({method:o,response:i,status:c,transport:a})=>{c==="success"&&e===o&&(n[i]=a.request)})),o=>n[o]||t.request}async function Kn(t,e){const{address:n,abi:r,args:s,eventName:o,fromBlock:i,strict:c,toBlock:a}=e,u=ee(t,{method:"eth_newFilter"}),l=o?$t({abi:r,args:s,eventName:o}):void 0,d=await t.request({method:"eth_newFilter",params:[{address:n,fromBlock:typeof i=="bigint"?D(i):i,toBlock:typeof a=="bigint"?D(a):a,topics:l}]});return{abi:r,args:s,eventName:o,id:d,request:u(d),strict:!!c,type:"event"}}async function Is(t,e){const{abi:n,address:r,args:s,functionName:o,...i}=e,c=Cn({abi:n,args:s,functionName:o});try{return await R(t,Yt,"estimateGas")({data:c,to:r,...i})}catch(a){const u=i.account?Nt(i.account):void 0;throw In(a,{abi:n,address:r,args:s,docsPath:"/docs/contract/estimateContractGas",functionName:o,sender:u==null?void 0:u.address})}}const rn="/docs/contract/decodeEventLog";function Oe(t){const{abi:e,data:n,strict:r,topics:s}=t,o=r??!0,[i,...c]=s;if(!i)throw new jr({docsPath:rn});const a=e.find(f=>f.type==="event"&&i===vn(bn(f)));if(!(a&&"name"in a)||a.type!=="event")throw new En(i,{docsPath:rn});const{name:u,inputs:l}=a,d=l==null?void 0:l.some(f=>!("name"in f&&f.name));let g=d?[]:{};const I=l.filter(f=>"indexed"in f&&f.indexed);for(let f=0;f<I.length;f++){const h=I[f],p=c[f];if(!p)throw new Jt({abiItem:a,param:h});g[d?f:h.name||f]=Es({param:h,value:p})}const w=l.filter(f=>!("indexed"in f&&f.indexed));if(w.length>0){if(n&&n!=="0x")try{const f=Sn(w,n);if(f)if(d)g=[...g,...f];else for(let h=0;h<w.length;h++)g[w[h].name]=f[h]}catch(f){if(o)throw f instanceof zr||f instanceof Gr?new Bt({abiItem:a,data:n,params:w,size:jt(n)}):f}else if(o)throw new Bt({abiItem:a,data:"0x",params:w,size:0})}return{eventName:u,args:Object.values(g).length>0?g:void 0}}function Es({param:t,value:e}){return t.type==="string"||t.type==="bytes"||t.type==="tuple"||t.type.match(/^(.*)\[(\d+)?\]$/)?e:(Sn([t],e)||[])[0]}function De({abi:t,eventName:e,logs:n,strict:r=!0}){return n.map(s=>{var o;try{const i=Oe({...s,abi:t,strict:r});return e&&!e.includes(i.eventName)?null:{...i,...s}}catch(i){let c,a;if(i instanceof En)return null;if(i instanceof Bt||i instanceof Jt){if(r)return null;c=i.abiItem.name,a=(o=i.abiItem.inputs)==null?void 0:o.some(u=>!("name"in u&&u.name))}return{...s,args:a?[]:{},eventName:c}}}).filter(Boolean)}async function Le(t,{address:e,blockHash:n,fromBlock:r,toBlock:s,event:o,events:i,args:c,strict:a}={}){const u=a??!1,l=i??(o?[o]:void 0);let d=[];l&&(d=[l.flatMap(f=>$t({abi:[f],eventName:f.name,args:c}))],o&&(d=d[0]));let g;n?g=await t.request({method:"eth_getLogs",params:[{address:e,topics:d,blockHash:n}]}):g=await t.request({method:"eth_getLogs",params:[{address:e,topics:d,fromBlock:typeof r=="bigint"?D(r):r,toBlock:typeof s=="bigint"?D(s):s}]});const I=g.map(w=>ft(w));return l?De({abi:l,logs:I,strict:u}):I}async function Yn(t,e){const{abi:n,address:r,args:s,blockHash:o,eventName:i,fromBlock:c,toBlock:a,strict:u}=e,l=i?wn({abi:n,name:i}):void 0,d=l?void 0:n.filter(g=>g.type==="event");return R(t,Le,"getLogs")({address:r,args:s,blockHash:o,event:l,events:d,fromBlock:c,toBlock:a,strict:u})}async function Jn(t,e){const{abi:n,address:r,args:s,dataSuffix:o,functionName:i,...c}=e,a=c.account?Nt(c.account):t.account,u=Cn({abi:n,args:s,functionName:i});try{const{data:l}=await R(t,Pt,"call")({batch:!1,data:`${u}${o?o.replace("0x",""):""}`,to:r,...c,account:a}),d=Wr({abi:n,args:s,functionName:i,data:l||"0x"}),g=n.filter(I=>"name"in I&&I.name===e.functionName);return{result:d,request:{abi:g,address:r,args:s,dataSuffix:o,functionName:i,...c,account:a}}}catch(l){throw In(l,{abi:n,address:r,args:s,docsPath:"/docs/contract/simulateContract",functionName:i,sender:a==null?void 0:a.address})}}async function ne(t,{filter:e}){const n="strict"in e&&e.strict,r=await e.request({method:"eth_getFilterChanges",params:[e.id]});if(typeof r[0]=="string")return r;const s=r.map(o=>ft(o));return!("abi"in e)||!e.abi?s:De({abi:e.abi,logs:s,strict:n})}async function re(t,{filter:e}){return e.request({method:"eth_uninstallFilter",params:[e.id]})}function Xn(t,e){const{abi:n,address:r,args:s,batch:o=!0,eventName:i,fromBlock:c,onError:a,onLogs:u,poll:l,pollingInterval:d=t.pollingInterval,strict:g}=e;return(typeof l<"u"?l:typeof c=="bigint"?!0:!(t.transport.type==="webSocket"||t.transport.type==="fallback"&&t.transport.transports[0].config.type==="webSocket"))?(()=>{const h=g??!1,p=bt(["watchContractEvent",r,s,o,t.uid,i,d,h,c]);return _t(p,{onLogs:u,onError:a},y=>{let v;c!==void 0&&(v=c-1n);let m,C=!1;const b=Xt(async()=>{var E;if(!C){try{m=await R(t,Kn,"createContractEventFilter")({abi:n,address:r,args:s,eventName:i,strict:h,fromBlock:c})}catch{}C=!0;return}try{let S;if(m)S=await R(t,ne,"getFilterChanges")({filter:m});else{const A=await R(t,qt,"getBlockNumber")({});v&&v!==A?S=await R(t,Yn,"getContractEvents")({abi:n,address:r,args:s,eventName:i,fromBlock:v+1n,toBlock:A,strict:h}):S=[],v=A}if(S.length===0)return;if(o)y.onLogs(S);else for(const A of S)y.onLogs([A])}catch(S){m&&S instanceof Bn&&(C=!1),(E=y.onError)==null||E.call(y,S)}},{emitOnBegin:!0,interval:d});return async()=>{m&&await R(t,re,"uninstallFilter")({filter:m}),b()}})})():(()=>{const h=g??!1,p=bt(["watchContractEvent",r,s,o,t.uid,i,d,h]);let y=!0,v=()=>y=!1;return _t(p,{onLogs:u,onError:a},m=>((async()=>{try{const C=(()=>{if(t.transport.type==="fallback"){const S=t.transport.transports.find(A=>A.config.type==="webSocket");return S?S.value:t.transport}return t.transport})(),b=i?$t({abi:n,eventName:i,args:s}):[],{unsubscribe:E}=await C.subscribe({params:["logs",{address:r,topics:b}],onData(S){var k;if(!y)return;const A=S.result;try{const{eventName:x,args:P}=Oe({abi:n,data:A.data,topics:A.topics,strict:g}),q=ft(A,{args:P,eventName:x});m.onLogs([q])}catch(x){let P,q;if(x instanceof Bt||x instanceof Jt){if(g)return;P=x.abiItem.name,q=(k=x.abiItem.inputs)==null?void 0:k.some(B=>!("name"in B&&B.name))}const Z=ft(A,{args:q?[]:{},eventName:P});m.onLogs([Z])}},onError(S){var A;(A=m.onError)==null||A.call(m,S)}});v=E,y||v()}catch(C){a==null||a(C)}})(),()=>v()))})()}class Ss extends mn{constructor({address:e}){super(`No EIP-712 domain found on contract "${e}".`,{metaMessages:["Ensure that:",`- The contract is deployed at the address "${e}".`,"- `eip712Domain()` function exists on the contract.","- `eip712Domain()` function matches signature to ERC-5267 specification."]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Eip712DomainNotFoundError"})}}async function Bs(t,e){const{address:n,factory:r,factoryData:s}=e;try{const[o,i,c,a,u,l,d]=await R(t,Qt,"readContract")({abi:_s,address:n,functionName:"eip712Domain",factory:r,factoryData:s});return{domain:{name:i,version:c,chainId:Number(a),verifyingContract:u,salt:l},extensions:d,fields:o}}catch(o){const i=o;throw i.name==="ContractFunctionExecutionError"&&i.cause.name==="ContractFunctionZeroDataError"?new Ss({address:n}):i}}const _s=[{inputs:[],name:"eip712Domain",outputs:[{name:"fields",type:"bytes1"},{name:"name",type:"string"},{name:"version",type:"string"},{name:"chainId",type:"uint256"},{name:"verifyingContract",type:"address"},{name:"salt",type:"bytes32"},{name:"extensions",type:"uint256[]"}],stateMutability:"view",type:"function"}];async function xs(t,{chain:e}){const{id:n,name:r,nativeCurrency:s,rpcUrls:o,blockExplorers:i}=e;await t.request({method:"wallet_addEthereumChain",params:[{chainId:D(n),chainName:r,nativeCurrency:s,rpcUrls:o.default.http,blockExplorerUrls:i?Object.values(i).map(({url:c})=>c):void 0}]},{dedupe:!0,retryCount:0})}function As(t,e={}){const{key:n="fallback",name:r="Fallback",rank:s=!1,retryCount:o,retryDelay:i}=e;return({chain:c,pollingInterval:a=4e3,timeout:u,...l})=>{let d=t,g=()=>{};const I=ke({key:n,name:r,async request({method:w,params:f}){const h=async(p=0)=>{const y=d[p]({...l,chain:c,retryCount:0,timeout:u});try{const v=await y.request({method:w,params:f});return g({method:w,params:f,response:v,transport:y,status:"success"}),v}catch(v){if(g({error:v,method:w,params:f,transport:y,status:"error"}),Ts(v)||p===d.length-1)throw v;return h(p+1)}};return h()},retryCount:o,retryDelay:i,type:"fallback"},{onResponse:w=>g=w,transports:d.map(w=>w({chain:c,retryCount:0}))});if(s){const w=typeof s=="object"?s:{};ks({chain:c,interval:w.interval??a,onTransports:f=>d=f,sampleCount:w.sampleCount,timeout:w.timeout,transports:d,weights:w.weights})}return I}}function Ts(t){return"code"in t&&typeof t.code=="number"&&(t.code===Zr.code||t.code===U.code||t.code===5e3)}function ks({chain:t,interval:e=4e3,onTransports:n,sampleCount:r=10,timeout:s=1e3,transports:o,weights:i={}}){const{stability:c=.7,latency:a=.3}=i,u=[],l=async()=>{const d=await Promise.all(o.map(async w=>{const f=w({chain:t,retryCount:0,timeout:s}),h=Date.now();let p,y;try{await f.request({method:"net_listening"}),y=1}catch{y=0}finally{p=Date.now()}return{latency:p-h,success:y}}));u.push(d),u.length>r&&u.shift();const g=Math.max(...u.map(w=>Math.max(...w.map(({latency:f})=>f)))),I=o.map((w,f)=>{const h=u.map(C=>C[f].latency),y=1-h.reduce((C,b)=>C+b,0)/h.length/g,v=u.map(C=>C[f].success),m=v.reduce((C,b)=>C+b,0)/v.length;return m===0?[0,f]:[a*y+c*m,f]}).sort((w,f)=>f[0]-w[0]);n(I.map(([,w])=>o[w])),await Vr(e),l()};l()}async function Qn(t,{blockNumber:e,blockTag:n,name:r,universalResolverAddress:s}){let o=s;if(!o){if(!t.chain)throw new Error("client chain not configured. universalResolverAddress is required.");o=Kr({blockNumber:e,chain:t.chain,contract:"ensUniversalResolver"})}const[i]=await R(t,Qt,"readContract")({address:o,abi:[{inputs:[{type:"bytes"}],name:"findResolver",outputs:[{type:"address"},{type:"bytes32"}],stateMutability:"view",type:"function"}],functionName:"findResolver",args:[Ne(Yr(r))],blockNumber:e,blockTag:n});return i}async function Ns(t){const e=ee(t,{method:"eth_newBlockFilter"}),n=await t.request({method:"eth_newBlockFilter"});return{id:n,request:e(n),type:"block"}}async function tr(t,{address:e,args:n,event:r,events:s,fromBlock:o,strict:i,toBlock:c}={}){const a=s??(r?[r]:void 0),u=ee(t,{method:"eth_newFilter"});let l=[];a&&(l=[a.flatMap(I=>$t({abi:[I],eventName:I.name,args:n}))],r&&(l=l[0]));const d=await t.request({method:"eth_newFilter",params:[{address:e,fromBlock:typeof o=="bigint"?D(o):o,toBlock:typeof c=="bigint"?D(c):c,...l.length?{topics:l}:{}}]});return{abi:a,args:n,eventName:r?r.name:void 0,fromBlock:o,id:d,request:u(d),strict:!!i,toBlock:c,type:"event"}}async function er(t){const e=ee(t,{method:"eth_newPendingTransactionFilter"}),n=await t.request({method:"eth_newPendingTransactionFilter"});return{id:n,request:e(n),type:"transaction"}}async function Ps(t){const e=await t.request({method:"eth_blobBaseFee"});return BigInt(e)}async function nr(t,{blockHash:e,blockNumber:n,blockTag:r="latest"}={}){const s=n!==void 0?D(n):void 0;let o;return e?o=await t.request({method:"eth_getBlockTransactionCountByHash",params:[e]},{dedupe:!0}):o=await t.request({method:"eth_getBlockTransactionCountByNumber",params:[s||r]},{dedupe:!!s}),Pe(o)}async function Wt(t,{address:e,blockNumber:n,blockTag:r="latest"}){const s=n!==void 0?D(n):void 0,o=await t.request({method:"eth_getCode",params:[e,s||r]},{dedupe:!!s});if(o!=="0x")return o}function qs(t){var e;return{baseFeePerGas:t.baseFeePerGas.map(n=>BigInt(n)),gasUsedRatio:t.gasUsedRatio,oldestBlock:BigInt(t.oldestBlock),reward:(e=t.reward)==null?void 0:e.map(n=>n.map(r=>BigInt(r)))}}async function rr(t,{blockCount:e,blockNumber:n,blockTag:r="latest",rewardPercentiles:s}){const o=n?D(n):void 0,i=await t.request({method:"eth_feeHistory",params:[D(e),o||r,s]},{dedupe:!!o});return qs(i)}async function $s(t,{filter:e}){const n=e.strict??!1,s=(await e.request({method:"eth_getFilterLogs",params:[e.id]})).map(o=>ft(o));return e.abi?De({abi:e.abi,logs:s,strict:n}):s}const Fs=/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/,Rs=/^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/,ue=new Map;async function Os(t){const{getSocket:e,key:n="socket",reconnect:r=!0,url:s}=t,{attempts:o=5,delay:i=2e3}=typeof r=="object"?r:{};let c=ue.get(`${n}:${s}`);if(c)return c;let a=0;const{schedule:u}=Jr({id:`${n}:${s}`,fn:async()=>{const g=new Map,I=new Map;let w,f;async function h(){return e({onError(p){var y,v;w=p;for(const m of g.values())(y=m.onError)==null||y.call(m,w);for(const m of I.values())(v=m.onError)==null||v.call(m,w);g.clear(),I.clear(),r&&a<o&&setTimeout(async()=>{a++,f=await h().catch(console.error)},i)},onOpen(){w=void 0,a=0},onResponse(p){const y=p.method==="eth_subscription",v=y?p.params.subscription:p.id,m=y?I:g,C=m.get(v);C&&C.onResponse(p),y||m.delete(v)}})}return f=await h(),w=void 0,c={close(){f.close(),ue.delete(`${n}:${s}`)},socket:f,request({body:p,onError:y,onResponse:v}){w&&y&&y(w);const m=p.id??Qr.take(),C=b=>{var E;typeof b.id=="number"&&m!==b.id||(p.method==="eth_subscribe"&&typeof b.result=="string"&&I.set(b.result,{onResponse:C,onError:y}),p.method==="eth_unsubscribe"&&I.delete((E=p.params)==null?void 0:E[0]),v(b))};g.set(m,{onResponse:C,onError:y});try{f.request({body:{jsonrpc:"2.0",id:m,...p}})}catch(b){y==null||y(b)}},requestAsync({body:p,timeout:y=1e4}){return qe(()=>new Promise((v,m)=>this.request({body:p,onError:m,onResponse:v})),{errorInstance:new Xr({body:p,url:s}),timeout:y})},requests:g,subscriptions:I,url:s},ue.set(`${n}:${s}`,c),[c]}}),[l,[d]]=await u();return d}async function Mt(t,e={}){const{reconnect:n}=e;return Os({async getSocket({onError:r,onOpen:s,onResponse:o}){const i=await ts(()=>import("./native-B8WyFf_Z.js"),[]).then(d=>d.WebSocket),c=new i(t);function a(){c.removeEventListener("close",a),c.removeEventListener("message",u),c.removeEventListener("error",r),c.removeEventListener("open",s)}function u({data:d}){o(JSON.parse(d))}c.addEventListener("close",a),c.addEventListener("message",u),c.addEventListener("error",r),c.addEventListener("open",s),c.readyState===i.CONNECTING&&await new Promise((d,g)=>{c&&(c.onopen=d,c.onerror=g)});const{close:l}=c;return Object.assign(c,{close(){l.bind(c)(),a()},request({body:d}){if(c.readyState===c.CLOSED||c.readyState===c.CLOSING)throw new es({body:d,url:c.url,details:"Socket is closed."});return c.send(JSON.stringify(d))}})},reconnect:n,url:t})}function Ds(t,{body:e,onError:n,onResponse:r}){return t.request({body:e,onError:n,onResponse:r}),t}async function Ls(t,{body:e,timeout:n=1e4}){return t.requestAsync({body:e,timeout:n})}async function Ms(t){const e=await Mt(t);return Object.assign(e.socket,{requests:e.requests,subscriptions:e.subscriptions})}const de={http(t,e){return ns(t).request(e)},webSocket:Ds,webSocketAsync:Ls};function Us(t){const{domain:e={},message:n,primaryType:r}=t,s={EIP712Domain:ur({domain:e}),...t.types};ar({domain:e,message:n,primaryType:r,types:s});const o=["0x1901"];return e&&o.push(Hs({domain:e,types:s})),r!=="EIP712Domain"&&o.push(sr({data:n,primaryType:r,types:s})),X(_n(o))}function Hs({domain:t,types:e}){return sr({data:t,primaryType:"EIP712Domain",types:e})}function sr({data:t,primaryType:e,types:n}){const r=or({data:t,primaryType:e,types:n});return X(r)}function or({data:t,primaryType:e,types:n}){const r=[{type:"bytes32"}],s=[js({primaryType:e,types:n})];for(const o of n[e]){const[i,c]=cr({types:n,name:o.name,type:o.type,value:t[o.name]});r.push(i),s.push(c)}return Kt(r,s)}function js({primaryType:t,types:e}){const n=Ne(zs({primaryType:t,types:e}));return X(n)}function zs({primaryType:t,types:e}){let n="";const r=ir({primaryType:t,types:e});r.delete(t);const s=[t,...Array.from(r).sort()];for(const o of s)n+=`${o}(${e[o].map(({name:i,type:c})=>`${c} ${i}`).join(",")})`;return n}function ir({primaryType:t,types:e},n=new Set){const r=t.match(/^\w*/u),s=r==null?void 0:r[0];if(n.has(s)||e[s]===void 0)return n;n.add(s);for(const o of e[s])ir({primaryType:o.type,types:e},n);return n}function cr({types:t,name:e,type:n,value:r}){if(t[n]!==void 0)return[{type:"bytes32"},X(or({data:r,primaryType:n,types:t}))];if(n==="bytes")return r=`0x${(r.length%2?"0":"")+r.slice(2)}`,[{type:"bytes32"},X(r)];if(n==="string")return[{type:"bytes32"},X(Ne(r))];if(n.lastIndexOf("]")===n.length-1){const s=n.slice(0,n.lastIndexOf("[")),o=r.map(i=>cr({name:e,type:s,types:t,value:i}));return[{type:"bytes32"},X(Kt(o.map(([i])=>i),o.map(([,i])=>i)))]}return[{type:n},r]}function Gs(t){const{domain:e,message:n,primaryType:r,types:s}=t,o=(a,u)=>{const l={...u};for(const d of a){const{name:g,type:I}=d;I==="address"&&(l[g]=l[g].toLowerCase())}return l},i=s.EIP712Domain?e?o(s.EIP712Domain,e):{}:{},c=(()=>{if(r!=="EIP712Domain")return o(s[r],n)})();return bt({domain:i,message:c,primaryType:r,types:s})}function ar(t){const{domain:e,message:n,primaryType:r,types:s}=t,o=(i,c)=>{for(const a of i){const{name:u,type:l}=a,d=c[u],g=l.match(Rs);if(g&&(typeof d=="number"||typeof d=="bigint")){const[f,h,p]=g;D(d,{signed:h==="int",size:Number.parseInt(p)/8})}if(l==="address"&&typeof d=="string"&&!rs(d))throw new ss({address:d});const I=l.match(Fs);if(I){const[f,h]=I;if(h&&jt(d)!==Number.parseInt(h))throw new os({expectedSize:Number.parseInt(h),givenSize:jt(d)})}const w=s[l];w&&o(w,d)}};s.EIP712Domain&&e&&o(s.EIP712Domain,e),r!=="EIP712Domain"&&o(s[r],n)}function ur({domain:t}){return[typeof(t==null?void 0:t.name)=="string"&&{name:"name",type:"string"},(t==null?void 0:t.version)&&{name:"version",type:"string"},typeof(t==null?void 0:t.chainId)=="number"&&{name:"chainId",type:"uint256"},(t==null?void 0:t.verifyingContract)&&{name:"verifyingContract",type:"address"},(t==null?void 0:t.salt)&&{name:"salt",type:"bytes32"}].filter(Boolean)}const Ws=`Ethereum Signed Message:
`;function Zs(t){const e=typeof t=="string"?ve(t):typeof t.raw=="string"?t.raw:xn(t.raw),n=ve(`${Ws}${jt(e)}`);return _n([n,e])}function dr(t,e){return X(Zs(t),e)}const lr="0x6492649264926492649264926492649264926492649264926492649264926492";function Vs(t){return is(t,-32)===lr}function Ks(t){const{address:e,data:n,signature:r}=t;return cs([Kt([{type:"address"},{type:"bytes"},{type:"bytes"}],[e,n,r]),lr])}function Ys(t){return t.map(e=>({...e,value:BigInt(e.value)}))}function Js(t){return{...t,balance:t.balance?BigInt(t.balance):void 0,nonce:t.nonce?Pe(t.nonce):void 0,storageProof:t.storageProof?Ys(t.storageProof):void 0}}async function fr(t,{address:e,blockNumber:n,blockTag:r,storageKeys:s}){const o=r??"latest",i=n!==void 0?D(n):void 0,c=await t.request({method:"eth_getProof",params:[e,s,i||o]});return Js(c)}async function hr(t,{address:e,blockNumber:n,blockTag:r="latest",slot:s}){const o=n!==void 0?D(n):void 0;return await t.request({method:"eth_getStorageAt",params:[e,s,o||r]})}async function gr(t,{hash:e,transactionReceipt:n}){const[r,s]=await Promise.all([R(t,qt,"getBlockNumber")({}),e?R(t,te,"getTransaction")({hash:e}):void 0]),o=(n==null?void 0:n.blockNumber)||(s==null?void 0:s.blockNumber);return o?r-o+1n:0n}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const pr=BigInt(0),se=BigInt(1),Xs=BigInt(2),oe=t=>t instanceof Uint8Array,Qs=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function vt(t){if(!oe(t))throw new Error("Uint8Array expected");let e="";for(let n=0;n<t.length;n++)e+=Qs[t[n]];return e}function yr(t){const e=t.toString(16);return e.length&1?`0${e}`:e}function Me(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return BigInt(t===""?"0":`0x${t}`)}function Ct(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);const e=t.length;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);const n=new Uint8Array(e/2);for(let r=0;r<n.length;r++){const s=r*2,o=t.slice(s,s+2),i=Number.parseInt(o,16);if(Number.isNaN(i)||i<0)throw new Error("Invalid byte sequence");n[r]=i}return n}function lt(t){return Me(vt(t))}function Ue(t){if(!oe(t))throw new Error("Uint8Array expected");return Me(vt(Uint8Array.from(t).reverse()))}function It(t,e){return Ct(t.toString(16).padStart(e*2,"0"))}function He(t,e){return It(t,e).reverse()}function to(t){return Ct(yr(t))}function K(t,e,n){let r;if(typeof e=="string")try{r=Ct(e)}catch(o){throw new Error(`${t} must be valid hex string, got "${e}". Cause: ${o}`)}else if(oe(e))r=Uint8Array.from(e);else throw new Error(`${t} must be hex string or Uint8Array`);const s=r.length;if(typeof n=="number"&&s!==n)throw new Error(`${t} expected ${n} bytes, got ${s}`);return r}function xt(...t){const e=new Uint8Array(t.reduce((r,s)=>r+s.length,0));let n=0;return t.forEach(r=>{if(!oe(r))throw new Error("Uint8Array expected");e.set(r,n),n+=r.length}),e}function mr(t,e){if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function eo(t){if(typeof t!="string")throw new Error(`utf8ToBytes expected string, got ${typeof t}`);return new Uint8Array(new TextEncoder().encode(t))}function no(t){let e;for(e=0;t>pr;t>>=se,e+=1);return e}function ro(t,e){return t>>BigInt(e)&se}const so=(t,e,n)=>t|(n?se:pr)<<BigInt(e),je=t=>(Xs<<BigInt(t-1))-se,le=t=>new Uint8Array(t),sn=t=>Uint8Array.from(t);function wr(t,e,n){if(typeof t!="number"||t<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof n!="function")throw new Error("hmacFn must be a function");let r=le(t),s=le(t),o=0;const i=()=>{r.fill(1),s.fill(0),o=0},c=(...d)=>n(s,r,...d),a=(d=le())=>{s=c(sn([0]),d),r=c(),d.length!==0&&(s=c(sn([1]),d),r=c())},u=()=>{if(o++>=1e3)throw new Error("drbg: tried 1000 values");let d=0;const g=[];for(;d<e;){r=c();const I=r.slice();g.push(I),d+=r.length}return xt(...g)};return(d,g)=>{i(),a(d);let I;for(;!(I=g(u()));)a();return i(),I}}const oo={bigint:t=>typeof t=="bigint",function:t=>typeof t=="function",boolean:t=>typeof t=="boolean",string:t=>typeof t=="string",stringOrUint8Array:t=>typeof t=="string"||t instanceof Uint8Array,isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,e)=>e.Fp.isValid(t),hash:t=>typeof t=="function"&&Number.isSafeInteger(t.outputLen)};function Ft(t,e,n={}){const r=(s,o,i)=>{const c=oo[o];if(typeof c!="function")throw new Error(`Invalid validator "${o}", expected function`);const a=t[s];if(!(i&&a===void 0)&&!c(a,t))throw new Error(`Invalid param ${String(s)}=${a} (${typeof a}), expected ${o}`)};for(const[s,o]of Object.entries(e))r(s,o,!1);for(const[s,o]of Object.entries(n))r(s,o,!0);return t}const io=Object.freeze(Object.defineProperty({__proto__:null,bitGet:ro,bitLen:no,bitMask:je,bitSet:so,bytesToHex:vt,bytesToNumberBE:lt,bytesToNumberLE:Ue,concatBytes:xt,createHmacDrbg:wr,ensureBytes:K,equalBytes:mr,hexToBytes:Ct,hexToNumber:Me,numberToBytesBE:It,numberToBytesLE:He,numberToHexUnpadded:yr,numberToVarBytesBE:to,utf8ToBytes:eo,validateObject:Ft},Symbol.toStringTag,{value:"Module"}));function co(t,e){const n=Ce(t)?be(t):t,r=Ce(e)?be(e):e;return mr(n,r)}function on(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`Wrong positive integer: ${t}`)}function br(t,...e){if(!(t instanceof Uint8Array))throw new Error("Expected Uint8Array");if(e.length>0&&!e.includes(t.length))throw new Error(`Expected Uint8Array of length ${e}, not of length=${t.length}`)}function ao(t){if(typeof t!="function"||typeof t.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");on(t.outputLen),on(t.blockLen)}function Zt(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function uo(t,e){br(t);const n=e.outputLen;if(t.length<n)throw new Error(`digestInto() expects output buffer of length at least ${n}`)}const fe=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const vr=t=>t instanceof Uint8Array,he=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),J=(t,e)=>t<<32-e|t>>>e,lo=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!lo)throw new Error("Non little-endian hardware is not supported");function fo(t){if(typeof t!="string")throw new Error(`utf8ToBytes expected string, got ${typeof t}`);return new Uint8Array(new TextEncoder().encode(t))}function ze(t){if(typeof t=="string"&&(t=fo(t)),!vr(t))throw new Error(`expected Uint8Array, got ${typeof t}`);return t}function ho(...t){const e=new Uint8Array(t.reduce((r,s)=>r+s.length,0));let n=0;return t.forEach(r=>{if(!vr(r))throw new Error("Uint8Array expected");e.set(r,n),n+=r.length}),e}class Cr{clone(){return this._cloneInto()}}function go(t){const e=r=>t().update(ze(r)).digest(),n=t();return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=()=>t(),e}function po(t=32){if(fe&&typeof fe.getRandomValues=="function")return fe.getRandomValues(new Uint8Array(t));throw new Error("crypto.getRandomValues must be defined")}function yo(t,e,n,r){if(typeof t.setBigUint64=="function")return t.setBigUint64(e,n,r);const s=BigInt(32),o=BigInt(4294967295),i=Number(n>>s&o),c=Number(n&o),a=r?4:0,u=r?0:4;t.setUint32(e+a,i,r),t.setUint32(e+u,c,r)}class mo extends Cr{constructor(e,n,r,s){super(),this.blockLen=e,this.outputLen=n,this.padOffset=r,this.isLE=s,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=he(this.buffer)}update(e){Zt(this);const{view:n,buffer:r,blockLen:s}=this;e=ze(e);const o=e.length;for(let i=0;i<o;){const c=Math.min(s-this.pos,o-i);if(c===s){const a=he(e);for(;s<=o-i;i+=s)this.process(a,i);continue}r.set(e.subarray(i,i+c),this.pos),this.pos+=c,i+=c,this.pos===s&&(this.process(n,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){Zt(this),uo(e,this),this.finished=!0;const{buffer:n,view:r,blockLen:s,isLE:o}=this;let{pos:i}=this;n[i++]=128,this.buffer.subarray(i).fill(0),this.padOffset>s-i&&(this.process(r,0),i=0);for(let d=i;d<s;d++)n[d]=0;yo(r,s-8,BigInt(this.length*8),o),this.process(r,0);const c=he(e),a=this.outputLen;if(a%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const u=a/4,l=this.get();if(u>l.length)throw new Error("_sha2: outputLen bigger than state");for(let d=0;d<u;d++)c.setUint32(4*d,l[d],o)}digest(){const{buffer:e,outputLen:n}=this;this.digestInto(e);const r=e.slice(0,n);return this.destroy(),r}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:n,buffer:r,length:s,finished:o,destroyed:i,pos:c}=this;return e.length=s,e.pos=c,e.finished=o,e.destroyed=i,s%n&&e.buffer.set(r),e}}const wo=(t,e,n)=>t&e^~t&n,bo=(t,e,n)=>t&e^t&n^e&n,vo=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),st=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),ot=new Uint32Array(64);class Co extends mo{constructor(){super(64,32,8,!1),this.A=st[0]|0,this.B=st[1]|0,this.C=st[2]|0,this.D=st[3]|0,this.E=st[4]|0,this.F=st[5]|0,this.G=st[6]|0,this.H=st[7]|0}get(){const{A:e,B:n,C:r,D:s,E:o,F:i,G:c,H:a}=this;return[e,n,r,s,o,i,c,a]}set(e,n,r,s,o,i,c,a){this.A=e|0,this.B=n|0,this.C=r|0,this.D=s|0,this.E=o|0,this.F=i|0,this.G=c|0,this.H=a|0}process(e,n){for(let d=0;d<16;d++,n+=4)ot[d]=e.getUint32(n,!1);for(let d=16;d<64;d++){const g=ot[d-15],I=ot[d-2],w=J(g,7)^J(g,18)^g>>>3,f=J(I,17)^J(I,19)^I>>>10;ot[d]=f+ot[d-7]+w+ot[d-16]|0}let{A:r,B:s,C:o,D:i,E:c,F:a,G:u,H:l}=this;for(let d=0;d<64;d++){const g=J(c,6)^J(c,11)^J(c,25),I=l+g+wo(c,a,u)+vo[d]+ot[d]|0,f=(J(r,2)^J(r,13)^J(r,22))+bo(r,s,o)|0;l=u,u=a,a=c,c=i+I|0,i=o,o=s,s=r,r=I+f|0}r=r+this.A|0,s=s+this.B|0,o=o+this.C|0,i=i+this.D|0,c=c+this.E|0,a=a+this.F|0,u=u+this.G|0,l=l+this.H|0,this.set(r,s,o,i,c,a,u,l)}roundClean(){ot.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const Io=go(()=>new Co);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const M=BigInt(0),O=BigInt(1),at=BigInt(2),Eo=BigInt(3),Se=BigInt(4),cn=BigInt(5),an=BigInt(8);BigInt(9);BigInt(16);function H(t,e){const n=t%e;return n>=M?n:e+n}function So(t,e,n){if(n<=M||e<M)throw new Error("Expected power/modulo > 0");if(n===O)return M;let r=O;for(;e>M;)e&O&&(r=r*t%n),t=t*t%n,e>>=O;return r}function G(t,e,n){let r=t;for(;e-- >M;)r*=r,r%=n;return r}function Be(t,e){if(t===M||e<=M)throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);let n=H(t,e),r=e,s=M,o=O;for(;n!==M;){const c=r/n,a=r%n,u=s-o*c;r=n,n=a,s=o,o=u}if(r!==O)throw new Error("invert: does not exist");return H(s,e)}function Bo(t){const e=(t-O)/at;let n,r,s;for(n=t-O,r=0;n%at===M;n/=at,r++);for(s=at;s<t&&So(s,e,t)!==t-O;s++);if(r===1){const i=(t+O)/Se;return function(a,u){const l=a.pow(u,i);if(!a.eql(a.sqr(l),u))throw new Error("Cannot find square root");return l}}const o=(n+O)/at;return function(c,a){if(c.pow(a,e)===c.neg(c.ONE))throw new Error("Cannot find square root");let u=r,l=c.pow(c.mul(c.ONE,s),n),d=c.pow(a,o),g=c.pow(a,n);for(;!c.eql(g,c.ONE);){if(c.eql(g,c.ZERO))return c.ZERO;let I=1;for(let f=c.sqr(g);I<u&&!c.eql(f,c.ONE);I++)f=c.sqr(f);const w=c.pow(l,O<<BigInt(u-I-1));l=c.sqr(w),d=c.mul(d,w),g=c.mul(g,l),u=I}return d}}function _o(t){if(t%Se===Eo){const e=(t+O)/Se;return function(r,s){const o=r.pow(s,e);if(!r.eql(r.sqr(o),s))throw new Error("Cannot find square root");return o}}if(t%an===cn){const e=(t-cn)/an;return function(r,s){const o=r.mul(s,at),i=r.pow(o,e),c=r.mul(s,i),a=r.mul(r.mul(c,at),i),u=r.mul(c,r.sub(a,r.ONE));if(!r.eql(r.sqr(u),s))throw new Error("Cannot find square root");return u}}return Bo(t)}const xo=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Ao(t){const e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},n=xo.reduce((r,s)=>(r[s]="function",r),e);return Ft(t,n)}function To(t,e,n){if(n<M)throw new Error("Expected power > 0");if(n===M)return t.ONE;if(n===O)return e;let r=t.ONE,s=e;for(;n>M;)n&O&&(r=t.mul(r,s)),s=t.sqr(s),n>>=O;return r}function ko(t,e){const n=new Array(e.length),r=e.reduce((o,i,c)=>t.is0(i)?o:(n[c]=o,t.mul(o,i)),t.ONE),s=t.inv(r);return e.reduceRight((o,i,c)=>t.is0(i)?o:(n[c]=t.mul(o,n[c]),t.mul(o,i)),s),n}function Ir(t,e){const n=e!==void 0?e:t.toString(2).length,r=Math.ceil(n/8);return{nBitLength:n,nByteLength:r}}function No(t,e,n=!1,r={}){if(t<=M)throw new Error(`Expected Field ORDER > 0, got ${t}`);const{nBitLength:s,nByteLength:o}=Ir(t,e);if(o>2048)throw new Error("Field lengths over 2048 bytes are not supported");const i=_o(t),c=Object.freeze({ORDER:t,BITS:s,BYTES:o,MASK:je(s),ZERO:M,ONE:O,create:a=>H(a,t),isValid:a=>{if(typeof a!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof a}`);return M<=a&&a<t},is0:a=>a===M,isOdd:a=>(a&O)===O,neg:a=>H(-a,t),eql:(a,u)=>a===u,sqr:a=>H(a*a,t),add:(a,u)=>H(a+u,t),sub:(a,u)=>H(a-u,t),mul:(a,u)=>H(a*u,t),pow:(a,u)=>To(c,a,u),div:(a,u)=>H(a*Be(u,t),t),sqrN:a=>a*a,addN:(a,u)=>a+u,subN:(a,u)=>a-u,mulN:(a,u)=>a*u,inv:a=>Be(a,t),sqrt:r.sqrt||(a=>i(c,a)),invertBatch:a=>ko(c,a),cmov:(a,u,l)=>l?u:a,toBytes:a=>n?He(a,o):It(a,o),fromBytes:a=>{if(a.length!==o)throw new Error(`Fp.fromBytes: expected ${o}, got ${a.length}`);return n?Ue(a):lt(a)}});return Object.freeze(c)}function Er(t){if(typeof t!="bigint")throw new Error("field order must be bigint");const e=t.toString(2).length;return Math.ceil(e/8)}function Sr(t){const e=Er(t);return e+Math.ceil(e/2)}function Po(t,e,n=!1){const r=t.length,s=Er(e),o=Sr(e);if(r<16||r<o||r>1024)throw new Error(`expected ${o}-1024 bytes of input, got ${r}`);const i=n?lt(t):Ue(t),c=H(i,e-O)+O;return n?He(c,s):It(c,s)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const qo=BigInt(0),ge=BigInt(1);function $o(t,e){const n=(s,o)=>{const i=o.negate();return s?i:o},r=s=>{const o=Math.ceil(e/s)+1,i=2**(s-1);return{windows:o,windowSize:i}};return{constTimeNegate:n,unsafeLadder(s,o){let i=t.ZERO,c=s;for(;o>qo;)o&ge&&(i=i.add(c)),c=c.double(),o>>=ge;return i},precomputeWindow(s,o){const{windows:i,windowSize:c}=r(o),a=[];let u=s,l=u;for(let d=0;d<i;d++){l=u,a.push(l);for(let g=1;g<c;g++)l=l.add(u),a.push(l);u=l.double()}return a},wNAF(s,o,i){const{windows:c,windowSize:a}=r(s);let u=t.ZERO,l=t.BASE;const d=BigInt(2**s-1),g=2**s,I=BigInt(s);for(let w=0;w<c;w++){const f=w*a;let h=Number(i&d);i>>=I,h>a&&(h-=g,i+=ge);const p=f,y=f+Math.abs(h)-1,v=w%2!==0,m=h<0;h===0?l=l.add(n(v,o[p])):u=u.add(n(m,o[y]))}return{p:u,f:l}},wNAFCached(s,o,i,c){const a=s._WINDOW_SIZE||1;let u=o.get(s);return u||(u=this.precomputeWindow(s,a),a!==1&&o.set(s,c(u))),this.wNAF(a,u,i)}}}function Br(t){return Ao(t.Fp),Ft(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Ir(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Fo(t){const e=Br(t);Ft(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:n,Fp:r,a:s}=e;if(n){if(!r.eql(s,r.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof n!="object"||typeof n.beta!="bigint"||typeof n.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...e})}const{bytesToNumberBE:Ro,hexToBytes:Oo}=io,ut={Err:class extends Error{constructor(e=""){super(e)}},_parseInt(t){const{Err:e}=ut;if(t.length<2||t[0]!==2)throw new e("Invalid signature integer tag");const n=t[1],r=t.subarray(2,n+2);if(!n||r.length!==n)throw new e("Invalid signature integer: wrong length");if(r[0]&128)throw new e("Invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new e("Invalid signature integer: unnecessary leading zero");return{d:Ro(r),l:t.subarray(n+2)}},toSig(t){const{Err:e}=ut,n=typeof t=="string"?Oo(t):t;if(!(n instanceof Uint8Array))throw new Error("ui8a expected");let r=n.length;if(r<2||n[0]!=48)throw new e("Invalid signature tag");if(n[1]!==r-2)throw new e("Invalid signature: incorrect length");const{d:s,l:o}=ut._parseInt(n.subarray(2)),{d:i,l:c}=ut._parseInt(o);if(c.length)throw new e("Invalid signature: left bytes after parsing");return{r:s,s:i}},hexFromSig(t){const e=u=>Number.parseInt(u[0],16)&8?"00"+u:u,n=u=>{const l=u.toString(16);return l.length&1?`0${l}`:l},r=e(n(t.s)),s=e(n(t.r)),o=r.length/2,i=s.length/2,c=n(o),a=n(i);return`30${n(i+o+4)}02${a}${s}02${c}${r}`}},Q=BigInt(0),W=BigInt(1);BigInt(2);const un=BigInt(3);BigInt(4);function Do(t){const e=Fo(t),{Fp:n}=e,r=e.toBytes||((w,f,h)=>{const p=f.toAffine();return xt(Uint8Array.from([4]),n.toBytes(p.x),n.toBytes(p.y))}),s=e.fromBytes||(w=>{const f=w.subarray(1),h=n.fromBytes(f.subarray(0,n.BYTES)),p=n.fromBytes(f.subarray(n.BYTES,2*n.BYTES));return{x:h,y:p}});function o(w){const{a:f,b:h}=e,p=n.sqr(w),y=n.mul(p,w);return n.add(n.add(y,n.mul(w,f)),h)}if(!n.eql(n.sqr(e.Gy),o(e.Gx)))throw new Error("bad generator point: equation left != right");function i(w){return typeof w=="bigint"&&Q<w&&w<e.n}function c(w){if(!i(w))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function a(w){const{allowedPrivateKeyLengths:f,nByteLength:h,wrapPrivateKey:p,n:y}=e;if(f&&typeof w!="bigint"){if(w instanceof Uint8Array&&(w=vt(w)),typeof w!="string"||!f.includes(w.length))throw new Error("Invalid key");w=w.padStart(h*2,"0")}let v;try{v=typeof w=="bigint"?w:lt(K("private key",w,h))}catch{throw new Error(`private key must be ${h} bytes, hex or bigint, not ${typeof w}`)}return p&&(v=H(v,y)),c(v),v}const u=new Map;function l(w){if(!(w instanceof d))throw new Error("ProjectivePoint expected")}class d{constructor(f,h,p){if(this.px=f,this.py=h,this.pz=p,f==null||!n.isValid(f))throw new Error("x required");if(h==null||!n.isValid(h))throw new Error("y required");if(p==null||!n.isValid(p))throw new Error("z required")}static fromAffine(f){const{x:h,y:p}=f||{};if(!f||!n.isValid(h)||!n.isValid(p))throw new Error("invalid affine point");if(f instanceof d)throw new Error("projective point not allowed");const y=v=>n.eql(v,n.ZERO);return y(h)&&y(p)?d.ZERO:new d(h,p,n.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(f){const h=n.invertBatch(f.map(p=>p.pz));return f.map((p,y)=>p.toAffine(h[y])).map(d.fromAffine)}static fromHex(f){const h=d.fromAffine(s(K("pointHex",f)));return h.assertValidity(),h}static fromPrivateKey(f){return d.BASE.multiply(a(f))}_setWindowSize(f){this._WINDOW_SIZE=f,u.delete(this)}assertValidity(){if(this.is0()){if(e.allowInfinityPoint&&!n.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:f,y:h}=this.toAffine();if(!n.isValid(f)||!n.isValid(h))throw new Error("bad point: x or y not FE");const p=n.sqr(h),y=o(f);if(!n.eql(p,y))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:f}=this.toAffine();if(n.isOdd)return!n.isOdd(f);throw new Error("Field doesn't support isOdd")}equals(f){l(f);const{px:h,py:p,pz:y}=this,{px:v,py:m,pz:C}=f,b=n.eql(n.mul(h,C),n.mul(v,y)),E=n.eql(n.mul(p,C),n.mul(m,y));return b&&E}negate(){return new d(this.px,n.neg(this.py),this.pz)}double(){const{a:f,b:h}=e,p=n.mul(h,un),{px:y,py:v,pz:m}=this;let C=n.ZERO,b=n.ZERO,E=n.ZERO,S=n.mul(y,y),A=n.mul(v,v),k=n.mul(m,m),x=n.mul(y,v);return x=n.add(x,x),E=n.mul(y,m),E=n.add(E,E),C=n.mul(f,E),b=n.mul(p,k),b=n.add(C,b),C=n.sub(A,b),b=n.add(A,b),b=n.mul(C,b),C=n.mul(x,C),E=n.mul(p,E),k=n.mul(f,k),x=n.sub(S,k),x=n.mul(f,x),x=n.add(x,E),E=n.add(S,S),S=n.add(E,S),S=n.add(S,k),S=n.mul(S,x),b=n.add(b,S),k=n.mul(v,m),k=n.add(k,k),S=n.mul(k,x),C=n.sub(C,S),E=n.mul(k,A),E=n.add(E,E),E=n.add(E,E),new d(C,b,E)}add(f){l(f);const{px:h,py:p,pz:y}=this,{px:v,py:m,pz:C}=f;let b=n.ZERO,E=n.ZERO,S=n.ZERO;const A=e.a,k=n.mul(e.b,un);let x=n.mul(h,v),P=n.mul(p,m),q=n.mul(y,C),Z=n.add(h,p),B=n.add(v,m);Z=n.mul(Z,B),B=n.add(x,P),Z=n.sub(Z,B),B=n.add(h,y);let _=n.add(v,C);return B=n.mul(B,_),_=n.add(x,q),B=n.sub(B,_),_=n.add(p,y),b=n.add(m,C),_=n.mul(_,b),b=n.add(P,q),_=n.sub(_,b),S=n.mul(A,B),b=n.mul(k,q),S=n.add(b,S),b=n.sub(P,S),S=n.add(P,S),E=n.mul(b,S),P=n.add(x,x),P=n.add(P,x),q=n.mul(A,q),B=n.mul(k,B),P=n.add(P,q),q=n.sub(x,q),q=n.mul(A,q),B=n.add(B,q),x=n.mul(P,B),E=n.add(E,x),x=n.mul(_,B),b=n.mul(Z,b),b=n.sub(b,x),x=n.mul(Z,P),S=n.mul(_,S),S=n.add(S,x),new d(b,E,S)}subtract(f){return this.add(f.negate())}is0(){return this.equals(d.ZERO)}wNAF(f){return I.wNAFCached(this,u,f,h=>{const p=n.invertBatch(h.map(y=>y.pz));return h.map((y,v)=>y.toAffine(p[v])).map(d.fromAffine)})}multiplyUnsafe(f){const h=d.ZERO;if(f===Q)return h;if(c(f),f===W)return this;const{endo:p}=e;if(!p)return I.unsafeLadder(this,f);let{k1neg:y,k1:v,k2neg:m,k2:C}=p.splitScalar(f),b=h,E=h,S=this;for(;v>Q||C>Q;)v&W&&(b=b.add(S)),C&W&&(E=E.add(S)),S=S.double(),v>>=W,C>>=W;return y&&(b=b.negate()),m&&(E=E.negate()),E=new d(n.mul(E.px,p.beta),E.py,E.pz),b.add(E)}multiply(f){c(f);let h=f,p,y;const{endo:v}=e;if(v){const{k1neg:m,k1:C,k2neg:b,k2:E}=v.splitScalar(h);let{p:S,f:A}=this.wNAF(C),{p:k,f:x}=this.wNAF(E);S=I.constTimeNegate(m,S),k=I.constTimeNegate(b,k),k=new d(n.mul(k.px,v.beta),k.py,k.pz),p=S.add(k),y=A.add(x)}else{const{p:m,f:C}=this.wNAF(h);p=m,y=C}return d.normalizeZ([p,y])[0]}multiplyAndAddUnsafe(f,h,p){const y=d.BASE,v=(C,b)=>b===Q||b===W||!C.equals(y)?C.multiplyUnsafe(b):C.multiply(b),m=v(this,h).add(v(f,p));return m.is0()?void 0:m}toAffine(f){const{px:h,py:p,pz:y}=this,v=this.is0();f==null&&(f=v?n.ONE:n.inv(y));const m=n.mul(h,f),C=n.mul(p,f),b=n.mul(y,f);if(v)return{x:n.ZERO,y:n.ZERO};if(!n.eql(b,n.ONE))throw new Error("invZ was invalid");return{x:m,y:C}}isTorsionFree(){const{h:f,isTorsionFree:h}=e;if(f===W)return!0;if(h)return h(d,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:f,clearCofactor:h}=e;return f===W?this:h?h(d,this):this.multiplyUnsafe(e.h)}toRawBytes(f=!0){return this.assertValidity(),r(d,this,f)}toHex(f=!0){return vt(this.toRawBytes(f))}}d.BASE=new d(e.Gx,e.Gy,n.ONE),d.ZERO=new d(n.ZERO,n.ONE,n.ZERO);const g=e.nBitLength,I=$o(d,e.endo?Math.ceil(g/2):g);return{CURVE:e,ProjectivePoint:d,normPrivateKeyToScalar:a,weierstrassEquation:o,isWithinCurveOrder:i}}function Lo(t){const e=Br(t);return Ft(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}function Mo(t){const e=Lo(t),{Fp:n,n:r}=e,s=n.BYTES+1,o=2*n.BYTES+1;function i(B){return Q<B&&B<n.ORDER}function c(B){return H(B,r)}function a(B){return Be(B,r)}const{ProjectivePoint:u,normPrivateKeyToScalar:l,weierstrassEquation:d,isWithinCurveOrder:g}=Do({...e,toBytes(B,_,N){const F=_.toAffine(),$=n.toBytes(F.x),L=xt;return N?L(Uint8Array.from([_.hasEvenY()?2:3]),$):L(Uint8Array.from([4]),$,n.toBytes(F.y))},fromBytes(B){const _=B.length,N=B[0],F=B.subarray(1);if(_===s&&(N===2||N===3)){const $=lt(F);if(!i($))throw new Error("Point is not on curve");const L=d($);let j=n.sqrt(L);const z=(j&W)===W;return(N&1)===1!==z&&(j=n.neg(j)),{x:$,y:j}}else if(_===o&&N===4){const $=n.fromBytes(F.subarray(0,n.BYTES)),L=n.fromBytes(F.subarray(n.BYTES,2*n.BYTES));return{x:$,y:L}}else throw new Error(`Point of length ${_} was invalid. Expected ${s} compressed bytes or ${o} uncompressed bytes`)}}),I=B=>vt(It(B,e.nByteLength));function w(B){const _=r>>W;return B>_}function f(B){return w(B)?c(-B):B}const h=(B,_,N)=>lt(B.slice(_,N));class p{constructor(_,N,F){this.r=_,this.s=N,this.recovery=F,this.assertValidity()}static fromCompact(_){const N=e.nByteLength;return _=K("compactSignature",_,N*2),new p(h(_,0,N),h(_,N,2*N))}static fromDER(_){const{r:N,s:F}=ut.toSig(K("DER",_));return new p(N,F)}assertValidity(){if(!g(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!g(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(_){return new p(this.r,this.s,_)}recoverPublicKey(_){const{r:N,s:F,recovery:$}=this,L=E(K("msgHash",_));if($==null||![0,1,2,3].includes($))throw new Error("recovery id invalid");const j=$===2||$===3?N+e.n:N;if(j>=n.ORDER)throw new Error("recovery id 2 or 3 invalid");const z=$&1?"03":"02",et=u.fromHex(z+I(j)),nt=a(j),gt=c(-L*nt),Et=c(F*nt),rt=u.BASE.multiplyAndAddUnsafe(et,gt,Et);if(!rt)throw new Error("point at infinify");return rt.assertValidity(),rt}hasHighS(){return w(this.s)}normalizeS(){return this.hasHighS()?new p(this.r,c(-this.s),this.recovery):this}toDERRawBytes(){return Ct(this.toDERHex())}toDERHex(){return ut.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return Ct(this.toCompactHex())}toCompactHex(){return I(this.r)+I(this.s)}}const y={isValidPrivateKey(B){try{return l(B),!0}catch{return!1}},normPrivateKeyToScalar:l,randomPrivateKey:()=>{const B=Sr(e.n);return Po(e.randomBytes(B),e.n)},precompute(B=8,_=u.BASE){return _._setWindowSize(B),_.multiply(BigInt(3)),_}};function v(B,_=!0){return u.fromPrivateKey(B).toRawBytes(_)}function m(B){const _=B instanceof Uint8Array,N=typeof B=="string",F=(_||N)&&B.length;return _?F===s||F===o:N?F===2*s||F===2*o:B instanceof u}function C(B,_,N=!0){if(m(B))throw new Error("first arg must be private key");if(!m(_))throw new Error("second arg must be public key");return u.fromHex(_).multiply(l(B)).toRawBytes(N)}const b=e.bits2int||function(B){const _=lt(B),N=B.length*8-e.nBitLength;return N>0?_>>BigInt(N):_},E=e.bits2int_modN||function(B){return c(b(B))},S=je(e.nBitLength);function A(B){if(typeof B!="bigint")throw new Error("bigint expected");if(!(Q<=B&&B<S))throw new Error(`bigint expected < 2^${e.nBitLength}`);return It(B,e.nByteLength)}function k(B,_,N=x){if(["recovered","canonical"].some(ct=>ct in N))throw new Error("sign() legacy options not supported");const{hash:F,randomBytes:$}=e;let{lowS:L,prehash:j,extraEntropy:z}=N;L==null&&(L=!0),B=K("msgHash",B),j&&(B=K("prehashed msgHash",F(B)));const et=E(B),nt=l(_),gt=[A(nt),A(et)];if(z!=null){const ct=z===!0?$(n.BYTES):z;gt.push(K("extraEntropy",ct))}const Et=xt(...gt),rt=et;function ce(ct){const pt=b(ct);if(!g(pt))return;const Ve=a(pt),yt=u.BASE.multiply(pt).toAffine(),V=c(yt.x);if(V===Q)return;const mt=c(Ve*c(rt+V*nt));if(mt===Q)return;let Ke=(yt.x===V?0:2)|Number(yt.y&W),Ye=mt;return L&&w(mt)&&(Ye=f(mt),Ke^=1),new p(V,Ye,Ke)}return{seed:Et,k2sig:ce}}const x={lowS:e.lowS,prehash:!1},P={lowS:e.lowS,prehash:!1};function q(B,_,N=x){const{seed:F,k2sig:$}=k(B,_,N),L=e;return wr(L.hash.outputLen,L.nByteLength,L.hmac)(F,$)}u.BASE._setWindowSize(8);function Z(B,_,N,F=P){var yt;const $=B;if(_=K("msgHash",_),N=K("publicKey",N),"strict"in F)throw new Error("options.strict was renamed to lowS");const{lowS:L,prehash:j}=F;let z,et;try{if(typeof $=="string"||$ instanceof Uint8Array)try{z=p.fromDER($)}catch(V){if(!(V instanceof ut.Err))throw V;z=p.fromCompact($)}else if(typeof $=="object"&&typeof $.r=="bigint"&&typeof $.s=="bigint"){const{r:V,s:mt}=$;z=new p(V,mt)}else throw new Error("PARSE");et=u.fromHex(N)}catch(V){if(V.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(L&&z.hasHighS())return!1;j&&(_=e.hash(_));const{r:nt,s:gt}=z,Et=E(_),rt=a(gt),ce=c(Et*rt),ct=c(nt*rt),pt=(yt=u.BASE.multiplyAndAddUnsafe(et,ce,ct))==null?void 0:yt.toAffine();return pt?c(pt.x)===nt:!1}return{CURVE:e,getPublicKey:v,getSharedSecret:C,sign:q,verify:Z,ProjectivePoint:u,Signature:p,utils:y}}class _r extends Cr{constructor(e,n){super(),this.finished=!1,this.destroyed=!1,ao(e);const r=ze(n);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,o=new Uint8Array(s);o.set(r.length>s?e.create().update(r).digest():r);for(let i=0;i<o.length;i++)o[i]^=54;this.iHash.update(o),this.oHash=e.create();for(let i=0;i<o.length;i++)o[i]^=106;this.oHash.update(o),o.fill(0)}update(e){return Zt(this),this.iHash.update(e),this}digestInto(e){Zt(this),br(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:n,iHash:r,finished:s,destroyed:o,blockLen:i,outputLen:c}=this;return e=e,e.finished=s,e.destroyed=o,e.blockLen=i,e.outputLen=c,e.oHash=n._cloneInto(e.oHash),e.iHash=r._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const xr=(t,e,n)=>new _r(t,e).update(n).digest();xr.create=(t,e)=>new _r(t,e);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Uo(t){return{hash:t,hmac:(e,...n)=>xr(t,e,ho(...n)),randomBytes:po}}function Ho(t,e){const n=r=>Mo({...t,...Uo(r)});return Object.freeze({...n(e),create:n})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ar=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),dn=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),jo=BigInt(1),_e=BigInt(2),ln=(t,e)=>(t+e/_e)/e;function zo(t){const e=Ar,n=BigInt(3),r=BigInt(6),s=BigInt(11),o=BigInt(22),i=BigInt(23),c=BigInt(44),a=BigInt(88),u=t*t*t%e,l=u*u*t%e,d=G(l,n,e)*l%e,g=G(d,n,e)*l%e,I=G(g,_e,e)*u%e,w=G(I,s,e)*I%e,f=G(w,o,e)*w%e,h=G(f,c,e)*f%e,p=G(h,a,e)*h%e,y=G(p,c,e)*f%e,v=G(y,n,e)*l%e,m=G(v,i,e)*w%e,C=G(m,r,e)*u%e,b=G(C,_e,e);if(!xe.eql(xe.sqr(b),t))throw new Error("Cannot find square root");return b}const xe=No(Ar,void 0,void 0,{sqrt:zo}),Tr=Ho({a:BigInt(0),b:BigInt(7),Fp:xe,n:dn,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const e=dn,n=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-jo*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),s=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),o=n,i=BigInt("0x100000000000000000000000000000000"),c=ln(o*t,e),a=ln(-r*t,e);let u=H(t-c*n-a*s,e),l=H(-c*r-a*o,e);const d=u>i,g=l>i;if(d&&(u=e-u),g&&(l=e-l),u>i||l>i)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:d,k1:u,k2neg:g,k2:l}}}},Io);BigInt(0);Tr.ProjectivePoint;function Go({r:t,s:e,v:n,yParity:r}){const s=(()=>{if(r===0||r===1)return r;if(n&&(n===27n||n===28n||n>=35n))return n%2n===0n?1:0;throw new Error("Invalid `v` or `yParity` value")})();return`0x${new Tr.Signature(Xe(t),Xe(e)).toCompactHex()}${s===0?"1b":"1c"}`}async function Ge(t,e){const{address:n,factory:r,factoryData:s,hash:o,signature:i,...c}=e,a=Ce(i)?i:typeof i=="object"&&"r"in i&&"s"in i?Go(i):xn(i),u=await(async()=>!r&&!s||Vs(a)||await R(t,Wt,"getCode")({address:n})?a:Ks({address:r,data:s,signature:a}))();try{const{data:l}=await R(t,Pt,"call")({data:An({abi:us,args:[n,o,u],bytecode:as}),...c});return co(l??"0x0","0x1")}catch(l){if(l instanceof ds)return!1;throw l}}async function kr(t,{address:e,message:n,factory:r,factoryData:s,signature:o,...i}){const c=dr(n);return Ge(t,{address:e,factory:r,factoryData:s,hash:c,signature:o,...i})}async function Nr(t,e){const{address:n,factory:r,factoryData:s,signature:o,message:i,primaryType:c,types:a,domain:u,...l}=e,d=Us({message:i,primaryType:c,types:a,domain:u});return Ge(t,{address:n,factory:r,factoryData:s,hash:d,signature:o,...l})}function Pr(t,{blockTag:e="latest",emitMissed:n=!1,emitOnBegin:r=!1,onBlock:s,onError:o,includeTransactions:i,poll:c,pollingInterval:a=t.pollingInterval}){const u=typeof c<"u"?c:!(t.transport.type==="webSocket"||t.transport.type==="fallback"&&t.transport.transports[0].config.type==="webSocket"),l=i??!1;let d;return u?(()=>{const w=bt(["watchBlocks",t.uid,e,n,r,l,a]);return _t(w,{onBlock:s,onError:o},f=>Xt(async()=>{var h;try{const p=await R(t,zt,"getBlock")({blockTag:e,includeTransactions:l});if(p.number&&(d!=null&&d.number)){if(p.number===d.number)return;if(p.number-d.number>1&&n)for(let y=(d==null?void 0:d.number)+1n;y<p.number;y++){const v=await R(t,zt,"getBlock")({blockNumber:y,includeTransactions:l});f.onBlock(v,d),d=v}}(!(d!=null&&d.number)||e==="pending"&&!(p!=null&&p.number)||p.number&&p.number>d.number)&&(f.onBlock(p,d),d=p)}catch(p){(h=f.onError)==null||h.call(f,p)}},{emitOnBegin:r,interval:a}))})():(()=>{let w=!0,f=()=>w=!1;return(async()=>{try{const h=(()=>{if(t.transport.type==="fallback"){const y=t.transport.transports.find(v=>v.config.type==="webSocket");return y?y.value:t.transport}return t.transport})(),{unsubscribe:p}=await h.subscribe({params:["newHeads"],onData(y){var C,b,E;if(!w)return;const m=(((E=(b=(C=t.chain)==null?void 0:C.formatters)==null?void 0:b.block)==null?void 0:E.format)||ls)(y.result);s(m,d),d=m},onError(y){o==null||o(y)}});f=p,w||f()}catch(h){o==null||o(h)}})(),()=>f()})()}function Wo(t,{address:e,args:n,batch:r=!0,event:s,events:o,fromBlock:i,onError:c,onLogs:a,poll:u,pollingInterval:l=t.pollingInterval,strict:d}){const g=typeof u<"u"?u:typeof i=="bigint"?!0:!(t.transport.type==="webSocket"||t.transport.type==="fallback"&&t.transport.transports[0].config.type==="webSocket"),I=d??!1;return g?(()=>{const h=bt(["watchEvent",e,n,r,t.uid,s,l,i]);return _t(h,{onLogs:a,onError:c},p=>{let y;i!==void 0&&(y=i-1n);let v,m=!1;const C=Xt(async()=>{var b;if(!m){try{v=await R(t,tr,"createEventFilter")({address:e,args:n,event:s,events:o,strict:I,fromBlock:i})}catch{}m=!0;return}try{let E;if(v)E=await R(t,ne,"getFilterChanges")({filter:v});else{const S=await R(t,qt,"getBlockNumber")({});y&&y!==S?E=await R(t,Le,"getLogs")({address:e,args:n,event:s,events:o,fromBlock:y+1n,toBlock:S}):E=[],y=S}if(E.length===0)return;if(r)p.onLogs(E);else for(const S of E)p.onLogs([S])}catch(E){v&&E instanceof Bn&&(m=!1),(b=p.onError)==null||b.call(p,E)}},{emitOnBegin:!0,interval:l});return async()=>{v&&await R(t,re,"uninstallFilter")({filter:v}),C()}})})():(()=>{let h=!0,p=()=>h=!1;return(async()=>{try{const y=(()=>{if(t.transport.type==="fallback"){const b=t.transport.transports.find(E=>E.config.type==="webSocket");return b?b.value:t.transport}return t.transport})(),v=o??(s?[s]:void 0);let m=[];v&&(m=[v.flatMap(E=>$t({abi:[E],eventName:E.name,args:n}))],s&&(m=m[0]));const{unsubscribe:C}=await y.subscribe({params:["logs",{address:e,topics:m}],onData(b){var S;if(!h)return;const E=b.result;try{const{eventName:A,args:k}=Oe({abi:v??[],data:E.data,topics:E.topics,strict:I}),x=ft(E,{args:k,eventName:A});a([x])}catch(A){let k,x;if(A instanceof Bt||A instanceof Jt){if(d)return;k=A.abiItem.name,x=(S=A.abiItem.inputs)==null?void 0:S.some(q=>!("name"in q&&q.name))}const P=ft(E,{args:x?[]:{},eventName:k});a([P])}},onError(b){c==null||c(b)}});p=C,h||p()}catch(y){c==null||c(y)}})(),()=>p()})()}function qr(t,{batch:e=!0,onError:n,onTransactions:r,poll:s,pollingInterval:o=t.pollingInterval}){return(typeof s<"u"?s:t.transport.type!=="webSocket")?(()=>{const u=bt(["watchPendingTransactions",t.uid,e,o]);return _t(u,{onTransactions:r,onError:n},l=>{let d;const g=Xt(async()=>{var I;try{if(!d)try{d=await R(t,er,"createPendingTransactionFilter")({});return}catch(f){throw g(),f}const w=await R(t,ne,"getFilterChanges")({filter:d});if(w.length===0)return;if(e)l.onTransactions(w);else for(const f of w)l.onTransactions([f])}catch(w){(I=l.onError)==null||I.call(l,w)}},{emitOnBegin:!0,interval:o});return async()=>{d&&await R(t,re,"uninstallFilter")({filter:d}),g()}})})():(()=>{let u=!0,l=()=>u=!1;return(async()=>{try{const{unsubscribe:d}=await t.transport.subscribe({params:["newPendingTransactions"],onData(g){if(!u)return;const I=g.result;r([I])},onError(g){n==null||n(g)}});l=d,u||l()}catch(d){n==null||n(d)}})(),()=>l()})()}function Zo(t){var d,g,I;const{scheme:e,statement:n,...r}=((d=t.match(Vo))==null?void 0:d.groups)??{},{chainId:s,expirationTime:o,issuedAt:i,notBefore:c,requestId:a,...u}=((g=t.match(Ko))==null?void 0:g.groups)??{},l=(I=t.split("Resources:")[1])==null?void 0:I.split(`
- `).slice(1);return{...r,...u,...s?{chainId:Number(s)}:{},...o?{expirationTime:new Date(o)}:{},...i?{issuedAt:new Date(i)}:{},...c?{notBefore:new Date(c)}:{},...a?{requestId:a}:{},...l?{resources:l}:{},...e?{scheme:e}:{},...n?{statement:n}:{}}}const Vo=/^(?:(?<scheme>[a-zA-Z][a-zA-Z0-9+-.]*):\/\/)?(?<domain>[a-zA-Z0-9+-.]*(?::[0-9]{1,5})?) (?:wants you to sign in with your Ethereum account:\n)(?<address>0x[a-fA-F0-9]{40})\n\n(?:(?<statement>.*)\n\n)?/,Ko=/(?:URI: (?<uri>.+))\n(?:Version: (?<version>.+))\n(?:Chain ID: (?<chainId>\d+))\n(?:Nonce: (?<nonce>[a-zA-Z0-9]+))\n(?:Issued At: (?<issuedAt>.+))(?:\nExpiration Time: (?<expirationTime>.+))?(?:\nNot Before: (?<notBefore>.+))?(?:\nRequest ID: (?<requestId>.+))?/;function Yo(t){const{address:e,domain:n,message:r,nonce:s,scheme:o,time:i=new Date}=t;if(n&&r.domain!==n||s&&r.nonce!==s||o&&r.scheme!==o||r.expirationTime&&i>=r.expirationTime||r.notBefore&&i<r.notBefore)return!1;try{if(!r.address||e&&!vs(r.address,e))return!1}catch{return!1}return!0}async function Jo(t,e){const{address:n,domain:r,message:s,nonce:o,scheme:i,signature:c,time:a=new Date,...u}=e,l=Zo(s);if(!l.address||!Yo({address:n,domain:r,message:l,nonce:o,scheme:i,time:a}))return!1;const g=dr(s);return Ge(t,{address:l.address,hash:g,signature:c,...u})}function Xo(t){return{call:e=>Pt(t,e),createBlockFilter:()=>Ns(t),createContractEventFilter:e=>Kn(t,e),createEventFilter:e=>tr(t,e),createPendingTransactionFilter:()=>er(t),estimateContractGas:e=>Is(t,e),estimateGas:e=>Yt(t,e),getBalance:e=>Hn(t,e),getBlobBaseFee:()=>Ps(t),getBlock:e=>zt(t,e),getBlockNumber:e=>qt(t,e),getBlockTransactionCount:e=>nr(t,e),getBytecode:e=>Wt(t,e),getChainId:()=>Fe(t),getCode:e=>Wt(t,e),getContractEvents:e=>Yn(t,e),getEip712Domain:e=>Bs(t,e),getEnsAddress:e=>Un(t,e),getEnsAvatar:e=>Mn(t,e),getEnsName:e=>Ln(t,e),getEnsResolver:e=>Qn(t,e),getEnsText:e=>Dn(t,e),getFeeHistory:e=>rr(t,e),estimateFeesPerGas:e=>On(t,e),getFilterChanges:e=>ne(t,e),getFilterLogs:e=>$s(t,e),getGasPrice:()=>Rn(t),getLogs:e=>Le(t,e),getProof:e=>fr(t,e),estimateMaxPriorityFeePerGas:e=>Fn(t,e),getStorageAt:e=>hr(t,e),getTransaction:e=>te(t,e),getTransactionConfirmations:e=>gr(t,e),getTransactionCount:e=>$n(t,e),getTransactionReceipt:e=>qn(t,e),multicall:e=>Pn(t,e),prepareTransactionRequest:e=>$e(t,e),readContract:e=>Qt(t,e),sendRawTransaction:e=>Nn(t,e),simulateContract:e=>Jn(t,e),verifyMessage:e=>kr(t,e),verifySiweMessage:e=>Jo(t,e),verifyTypedData:e=>Nr(t,e),uninstallFilter:e=>re(t,e),waitForTransactionReceipt:e=>kn(t,e),watchBlocks:e=>Pr(t,e),watchBlockNumber:e=>Tn(t,e),watchContractEvent:e=>Xn(t,e),watchEvent:e=>Wo(t,e),watchPendingTransactions:e=>qr(t,e)}}function $r(t,e){const{abi:n,args:r,bytecode:s,...o}=e,i=An({abi:n,args:r,bytecode:s});return Re(t,{...o,data:i})}async function Qo(t){var n;return((n=t.account)==null?void 0:n.type)==="local"?[t.account.address]:(await t.request({method:"eth_accounts"},{dedupe:!0})).map(r=>fs(r))}async function ti(t){return await t.request({method:"wallet_getPermissions"},{dedupe:!0})}async function ei(t){return(await t.request({method:"eth_requestAccounts"},{dedupe:!0,retryCount:0})).map(n=>tt(n))}async function ni(t,e){return t.request({method:"wallet_requestPermissions",params:[e]},{retryCount:0})}async function ri(t,e){var u,l,d,g;const{account:n=t.account,chain:r=t.chain,...s}=e;if(!n)throw new jn({docsPath:"/docs/actions/wallet/signTransaction"});const o=Nt(n);hs({account:o,...e});const i=await R(t,Fe,"getChainId")({});r!==null&&gs({currentChainId:i,chain:r});const c=(r==null?void 0:r.formatters)||((u=t.chain)==null?void 0:u.formatters),a=((l=c==null?void 0:c.transactionRequest)==null?void 0:l.format)||ps;return o.type==="local"?o.signTransaction({...s,chainId:i},{serializer:(g=(d=t.chain)==null?void 0:d.serializers)==null?void 0:g.transaction}):await t.request({method:"eth_signTransaction",params:[{...a(s),chainId:D(i),from:o.address}]},{retryCount:0})}async function Fr(t,e){const{account:n=t.account,domain:r,message:s,primaryType:o}=e;if(!n)throw new jn({docsPath:"/docs/actions/wallet/signTypedData"});const i=Nt(n),c={EIP712Domain:ur({domain:r}),...e.types};if(ar({domain:r,message:s,primaryType:o,types:c}),i.type==="local")return i.signTypedData({domain:r,message:s,primaryType:o,types:c});const a=Gs({domain:r,message:s,primaryType:o,types:c});return t.request({method:"eth_signTypedData_v4",params:[i.address,a]},{retryCount:0})}async function si(t,{id:e}){await t.request({method:"wallet_switchEthereumChain",params:[{chainId:D(e)}]},{retryCount:0})}async function oi(t,e){return await t.request({method:"wallet_watchAsset",params:e},{retryCount:0})}function fn(t){return{addChain:e=>xs(t,e),deployContract:e=>$r(t,e),getAddresses:()=>Qo(t),getChainId:()=>Fe(t),getPermissions:()=>ti(t),prepareTransactionRequest:e=>$e(t,e),requestAddresses:()=>ei(t),requestPermissions:e=>ni(t,e),sendRawTransaction:e=>Nn(t,e),sendTransaction:e=>Re(t,e),signMessage:e=>Gn(t,e),signTransaction:e=>ri(t,e),signTypedData:e=>Fr(t,e),switchChain:e=>si(t,e),watchAsset:e=>oi(t,e),writeContract:e=>zn(t,e)}}function Li(t,e={}){const{key:n="webSocket",name:r="WebSocket JSON-RPC",reconnect:s,retryDelay:o}=e;return({chain:i,retryCount:c,timeout:a})=>{var g;const u=e.retryCount??c,l=a??e.timeout??1e4,d=t||((g=i==null?void 0:i.rpcUrls.default.webSocket)==null?void 0:g[0]);if(!d)throw new ys;return ke({key:n,name:r,async request({method:I,params:w}){const f={method:I,params:w},h=await Mt(d,{reconnect:s}),{error:p,result:y}=await h.requestAsync({body:f,timeout:l});if(p)throw new Lt({body:f,error:p,url:d});return y},retryCount:u,retryDelay:o,timeout:l,type:"webSocket"},{getSocket(){return Ms(d)},getRpcClient(){return Mt(d)},async subscribe({params:I,onData:w,onError:f}){const h=await Mt(d),{result:p}=await new Promise((y,v)=>h.request({body:{method:"eth_subscribe",params:I},onResponse(m){if(m.error){v(m.error),f==null||f(m.error);return}if(typeof m.id=="number"){y(m);return}m.method==="eth_subscription"&&w(m.params)}}));return{subscriptionId:p,async unsubscribe(){return new Promise(y=>h.request({body:{method:"eth_unsubscribe",params:[p]},onResponse:y}))}}}})}}function T(t,e,n){const r=t[e.name];if(typeof r=="function")return r;const s=t[n];return typeof s=="function"?s:o=>e(t,o)}async function Mi(t,e){const{chainId:n,...r}=e,s=t.getClient({chainId:n});return T(s,Pt,"call")(r)}const Ut="2.11.6",ii=()=>`@wagmi/core@${Ut}`;var Rr=function(t,e,n,r){if(n==="a"&&!r)throw new TypeError("Private accessor was defined without a getter");if(typeof e=="function"?t!==e||!r:!e.has(t))throw new TypeError("Cannot read private member from an object whose class did not declare it");return n==="m"?r:n==="a"?r.call(t):r?r.value:e.get(t)},Vt,Or;class Y extends Error{get docsBaseUrl(){return"https://wagmi.sh/core"}get version(){return ii()}constructor(e,n={}){var o;super(),Vt.add(this),Object.defineProperty(this,"details",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"docsPath",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"metaMessages",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"shortMessage",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"WagmiCoreError"});const r=n.cause instanceof Y?n.cause.details:(o=n.cause)!=null&&o.message?n.cause.message:n.details,s=n.cause instanceof Y&&n.cause.docsPath||n.docsPath;this.message=[e||"An error occurred.","",...n.metaMessages?[...n.metaMessages,""]:[],...s?[`Docs: ${this.docsBaseUrl}${s}.html${n.docsSlug?`#${n.docsSlug}`:""}`]:[],...r?[`Details: ${r}`]:[],`Version: ${this.version}`].join(`
`),n.cause&&(this.cause=n.cause),this.details=r,this.docsPath=s,this.metaMessages=n.metaMessages,this.shortMessage=e}walk(e){return Rr(this,Vt,"m",Or).call(this,this,e)}}Vt=new WeakSet,Or=function t(e,n){return n!=null&&n(e)?e:e.cause?Rr(this,Vt,"m",t).call(this,e.cause,n):e};class At extends Y{constructor(){super("Chain not configured."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ChainNotConfiguredError"})}}class ci extends Y{constructor(){super("Connector already connected."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ConnectorAlreadyConnectedError"})}}class We extends Y{constructor(){super("Connector not connected."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ConnectorNotConnectedError"})}}class Ui extends Y{constructor(){super("Connector not found."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ConnectorNotFoundError"})}}class ai extends Y{constructor({address:e,connector:n}){super(`Account "${e}" not found for connector "${n.name}".`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ConnectorAccountNotFoundError"})}}class ui extends Y{constructor({connectionChainId:e,connectorChainId:n}){super(`The current chain of the connector (id: ${n}) does not match the connection's chain (id: ${e}).`,{metaMessages:[`Current Chain ID:  ${n}`,`Expected Chain ID: ${e}`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ConnectorChainMismatchError"})}}async function Hi(t,e){var r;let n;if(typeof e.connector=="function"?n=t._internal.connectors.setup(e.connector):n=e.connector,n.uid===t.state.current)throw new ci;try{t.setState(i=>({...i,status:"connecting"})),n.emitter.emit("message",{type:"connecting"});const s=await n.connect({chainId:e.chainId}),o=s.accounts;return n.emitter.off("connect",t._internal.events.connect),n.emitter.on("change",t._internal.events.change),n.emitter.on("disconnect",t._internal.events.disconnect),await((r=t.storage)==null?void 0:r.setItem("recentConnectorId",n.id)),t.setState(i=>({...i,connections:new Map(i.connections).set(n.uid,{accounts:o,chainId:s.chainId,connector:n}),current:n.uid,status:"connected"})),{accounts:o,chainId:s.chainId}}catch(s){throw t.setState(o=>({...o,status:o.current?"connected":"disconnected"})),s}}async function it(t,e={}){let n;if(e.connector){const{connector:u}=e,[l,d]=await Promise.all([u.getAccounts(),u.getChainId()]);n={accounts:l,chainId:d,connector:u}}else n=t.state.connections.get(t.state.current);if(!n)throw new We;const r=e.chainId??n.chainId,s=await n.connector.getChainId();if(s!==n.chainId)throw new ui({connectionChainId:n.chainId,connectorChainId:s});const o=n.connector;if(o.getClient)return o.getClient({chainId:r});const i=Nt(e.account??n.accounts[0]);i.address=tt(i.address);const c=t.chains.find(u=>u.id===r),a=await n.connector.getProvider({chainId:r});if(e.account&&!n.accounts.some(u=>u.toLowerCase()===i.address.toLowerCase()))throw new ai({address:i.address,connector:o});return Wn({account:i,chain:c,name:"Connector Client",transport:u=>Zn(a)({...u,retryCount:0})})}async function ji(t,e){const{account:n,chainId:r,connector:s,...o}=e;let i;return typeof n=="object"&&n.type==="local"?i=t.getClient({chainId:r}):i=await it(t,{account:n,chainId:r,connector:s}),await T(i,$r,"deployContract")({...o,...n?{account:n}:{},chain:r?{id:r}:null})}async function zi(t,e={}){var s,o;let n;if(e.connector)n=e.connector;else{const{connections:i,current:c}=t.state,a=i.get(c);n=a==null?void 0:a.connector}const r=t.state.connections;n&&(await n.disconnect(),n.emitter.off("change",t._internal.events.change),n.emitter.off("disconnect",t._internal.events.disconnect),n.emitter.on("connect",t._internal.events.connect),r.delete(n.uid)),t.setState(i=>{if(r.size===0)return{...i,connections:new Map,current:null,status:"disconnected"};const c=r.values().next().value;return{...i,connections:new Map(r),current:c.connector.uid}});{const i=t.state.current;if(!i)return;const c=(s=t.state.connections.get(i))==null?void 0:s.connector;if(!c)return;await((o=t.storage)==null?void 0:o.setItem("recentConnectorId",c.id))}}async function Gi(t,e){const{chainId:n,connector:r,...s}=e;let o;e.account?o=e.account:o=(await it(t,{account:e.account,chainId:n,connector:r})).account;const i=t.getClient({chainId:n});return T(i,Yt,"estimateGas")({...s,account:o})}function Tt(t){return typeof t=="number"?t:t==="wei"?0:Math.abs(ms[t])}async function Wi(t,e={}){const{chainId:n,formatUnits:r="gwei",...s}=e,o=t.getClient({chainId:n}),i=T(o,On,"estimateFeesPerGas"),{gasPrice:c,maxFeePerGas:a,maxPriorityFeePerGas:u}=await i({...s,chain:o.chain}),l=Tt(r);return{formatted:{gasPrice:c?dt(c,l):void 0,maxFeePerGas:a?dt(a,l):void 0,maxPriorityFeePerGas:u?dt(u,l):void 0},gasPrice:c,maxFeePerGas:a,maxPriorityFeePerGas:u}}async function Zi(t,e={}){const{chainId:n}=e,r=t.getClient({chainId:n});return T(r,Fn,"estimateMaxPriorityFeePerGas")({chain:r.chain})}function ie(t){const e=t.state.current,n=t.state.connections.get(e),r=n==null?void 0:n.accounts,s=r==null?void 0:r[0],o=t.chains.find(c=>c.id===(n==null?void 0:n.chainId)),i=t.state.status;switch(i){case"connected":return{address:s,addresses:r,chain:o,chainId:n==null?void 0:n.chainId,connector:n==null?void 0:n.connector,isConnected:!0,isConnecting:!1,isDisconnected:!1,isReconnecting:!1,status:i};case"reconnecting":return{address:s,addresses:r,chain:o,chainId:n==null?void 0:n.chainId,connector:n==null?void 0:n.connector,isConnected:!!s,isConnecting:!1,isDisconnected:!1,isReconnecting:!0,status:i};case"connecting":return{address:s,addresses:r,chain:o,chainId:n==null?void 0:n.chainId,connector:n==null?void 0:n.connector,isConnected:!1,isConnecting:!0,isDisconnected:!1,isReconnecting:!1,status:i};case"disconnected":return{address:void 0,addresses:void 0,chain:void 0,chainId:void 0,connector:void 0,isConnected:!1,isConnecting:!1,isDisconnected:!0,isReconnecting:!1,status:i}}}async function di(t,e){const{allowFailure:n=!0,chainId:r,contracts:s,...o}=e,i=t.getClient({chainId:r});return T(i,Pn,"multicall")({allowFailure:n,contracts:s,...o})}function li(t,e){const{chainId:n,...r}=e,s=t.getClient({chainId:n});return T(s,Qt,"readContract")(r)}async function Ae(t,e){var c;const{allowFailure:n=!0,blockNumber:r,blockTag:s,...o}=e,i=e.contracts;try{const a={};for(const[g,I]of i.entries()){const w=I.chainId??t.state.chainId;a[w]||(a[w]=[]),(c=a[w])==null||c.push({contract:I,index:g})}const u=()=>Object.entries(a).map(([g,I])=>di(t,{...o,allowFailure:n,blockNumber:r,blockTag:s,chainId:Number.parseInt(g),contracts:I.map(({contract:w})=>w)})),l=(await Promise.all(u())).flat(),d=Object.values(a).flatMap(g=>g.map(({index:I})=>I));return l.reduce((g,I,w)=>(g&&(g[d[w]]=I),g),[])}catch(a){if(a instanceof St)throw a;const u=()=>i.map(l=>li(t,{...l,blockNumber:r,blockTag:s}));return n?(await Promise.allSettled(u())).map(l=>l.status==="fulfilled"?{result:l.value,status:"success"}:{error:l.reason,result:void 0,status:"failure"}):await Promise.all(u())}}async function Vi(t,e){const{address:n,blockNumber:r,blockTag:s,chainId:o,token:i,unit:c="ether"}=e;if(i)try{return hn(t,{balanceAddress:n,chainId:o,symbolType:"string",tokenAddress:i})}catch(g){if(g instanceof St){const I=await hn(t,{balanceAddress:n,chainId:o,symbolType:"bytes32",tokenAddress:i}),w=Gt(Ie(I.symbol,{dir:"right"}));return{...I,symbol:w}}throw g}const a=t.getClient({chainId:o}),l=await T(a,Hn,"getBalance")(r?{address:n,blockNumber:r}:{address:n,blockTag:s}),d=t.chains.find(g=>g.id===o)??a.chain;return{decimals:d.nativeCurrency.decimals,formatted:dt(l,Tt(c)),symbol:d.nativeCurrency.symbol,value:l}}async function hn(t,e){const{balanceAddress:n,chainId:r,symbolType:s,tokenAddress:o,unit:i}=e,c={abi:[{type:"function",name:"balanceOf",stateMutability:"view",inputs:[{type:"address"}],outputs:[{type:"uint256"}]},{type:"function",name:"decimals",stateMutability:"view",inputs:[],outputs:[{type:"uint8"}]},{type:"function",name:"symbol",stateMutability:"view",inputs:[],outputs:[{type:s}]}],address:o},[a,u,l]=await Ae(t,{allowFailure:!1,contracts:[{...c,functionName:"balanceOf",args:[n],chainId:r},{...c,functionName:"decimals",chainId:r},{...c,functionName:"symbol",chainId:r}]}),d=dt(a??"0",Tt(i??u));return{decimals:u,formatted:d,symbol:l,value:a}}async function Ki(t,e={}){const{chainId:n,...r}=e,s=t.getClient({chainId:n});return{...await T(s,zt,"getBlock")(r),chainId:s.chain.id}}function Yi(t,e={}){const{chainId:n,...r}=e,s=t.getClient({chainId:n});return T(s,qt,"getBlockNumber")(r)}function Ji(t,e={}){const{chainId:n,...r}=e,s=t.getClient({chainId:n});return T(s,nr,"getBlockTransactionCount")(r)}async function Xi(t,e){const{chainId:n,...r}=e,s=t.getClient({chainId:n});return T(s,Wt,"getBytecode")(r)}function Qi(t){return t.state.chainId}function ht(t,e){if(t===e)return!0;if(t&&e&&typeof t=="object"&&typeof e=="object"){if(t.constructor!==e.constructor)return!1;let n,r;if(Array.isArray(t)&&Array.isArray(e)){if(n=t.length,n!==e.length)return!1;for(r=n;r--!==0;)if(!ht(t[r],e[r]))return!1;return!0}if(t.valueOf!==Object.prototype.valueOf)return t.valueOf()===e.valueOf();if(t.toString!==Object.prototype.toString)return t.toString()===e.toString();const s=Object.keys(t);if(n=s.length,n!==Object.keys(e).length)return!1;for(r=n;r--!==0;)if(!Object.prototype.hasOwnProperty.call(e,s[r]))return!1;for(r=n;r--!==0;){const o=s[r];if(o&&!ht(t[o],e[o]))return!1}return!0}return t!==t&&e!==e}let pe=[];function tc(t){const e=t.chains;return ht(pe,e)?pe:(pe=e,e)}function Dr(t,e={}){let n;try{n=t.getClient(e)}catch{}return n}let Rt=[];function fi(t){const e=[...t.state.connections.values()];return t.state.status==="reconnecting"||ht(Rt,e)?Rt:(Rt=e,e)}let ye=[];function ec(t){const e=t.connectors;return ht(ye,e)?ye:(ye=e,e)}function nc(t,e){const{chainId:n,...r}=e,s=t.getClient({chainId:n});return T(s,Un,"getEnsAddress")(r)}function rc(t,e){const{chainId:n,...r}=e,s=t.getClient({chainId:n});return T(s,Mn,"getEnsAvatar")(r)}function sc(t,e){const{chainId:n,...r}=e,s=t.getClient({chainId:n});return T(s,Ln,"getEnsName")(r)}function oc(t,e){const{chainId:n,...r}=e,s=t.getClient({chainId:n});return T(s,Qn,"getEnsResolver")(r)}function ic(t,e){const{chainId:n,...r}=e,s=t.getClient({chainId:n});return T(s,Dn,"getEnsText")(r)}function cc(t,e){const{chainId:n,...r}=e,s=t.getClient({chainId:n});return T(s,rr,"getFeeHistory")(r)}function ac(t,e={}){const{chainId:n}=e,r=t.getClient({chainId:n});return T(r,Rn,"getGasPrice")({})}async function uc(t,e){const{chainId:n,...r}=e,s=t.getClient({chainId:n});return T(s,fr,"getProof")(r)}function hi(t,e={}){const n=Dr(t,e);return n==null?void 0:n.extend(Xo)}async function dc(t,e){const{chainId:n,...r}=e,s=t.getClient({chainId:n});return T(s,hr,"getStorageAt")(r)}async function lc(t,e){const{address:n,chainId:r,formatUnits:s=18}=e;function o(i){return[{type:"function",name:"decimals",stateMutability:"view",inputs:[],outputs:[{type:"uint8"}]},{type:"function",name:"name",stateMutability:"view",inputs:[],outputs:[{type:i}]},{type:"function",name:"symbol",stateMutability:"view",inputs:[],outputs:[{type:i}]},{type:"function",name:"totalSupply",stateMutability:"view",inputs:[],outputs:[{type:"uint256"}]}]}try{const i=o("string"),c={address:n,abi:i,chainId:r},[a,u,l,d]=await Ae(t,{allowFailure:!0,contracts:[{...c,functionName:"decimals"},{...c,functionName:"name"},{...c,functionName:"symbol"},{...c,functionName:"totalSupply"}]});if(u.error instanceof St)throw u.error;if(l.error instanceof St)throw l.error;if(a.error)throw a.error;if(d.error)throw d.error;return{address:n,decimals:a.result,name:u.result,symbol:l.result,totalSupply:{formatted:dt(d.result,Tt(s)),value:d.result}}}catch(i){if(i instanceof St){const c=o("bytes32"),a={address:n,abi:c,chainId:r},[u,l,d,g]=await Ae(t,{allowFailure:!1,contracts:[{...a,functionName:"decimals"},{...a,functionName:"name"},{...a,functionName:"symbol"},{...a,functionName:"totalSupply"}]});return{address:n,decimals:u,name:Gt(Ie(l,{dir:"right"})),symbol:Gt(Ie(d,{dir:"right"})),totalSupply:{formatted:dt(g,Tt(s)),value:g}}}throw i}}function fc(t,e){const{chainId:n,...r}=e,s=t.getClient({chainId:n});return T(s,te,"getTransaction")(r)}function hc(t,e){const{chainId:n,...r}=e,s=t.getClient({chainId:n});return T(s,gr,"getTransactionConfirmations")(r)}async function gc(t,e){const{address:n,blockNumber:r,blockTag:s,chainId:o}=e,i=t.getClient({chainId:o});return T(i,$n,"getTransactionCount")(r?{address:n,blockNumber:r}:{address:n,blockTag:s})}async function pc(t,e){const{chainId:n,...r}=e,s=t.getClient({chainId:n});return T(s,qn,"getTransactionReceipt")(r)}async function yc(t,e={}){const n=await it(t,e);return n.extend(fn),n.extend(fn)}async function mc(t,e){const{account:n,chainId:r,...s}=e,o=n??ie(t).address,i=t.getClient({chainId:r});return T(i,$e,"prepareTransactionRequest")({...s,...o?{account:o}:{}})}let me=!1;async function gi(t,e={}){var u,l;if(me)return[];me=!0,t.setState(d=>({...d,status:d.current?"reconnecting":"connecting"}));const n=[];if((u=e.connectors)!=null&&u.length)for(const d of e.connectors){let g;typeof d=="function"?g=t._internal.connectors.setup(d):g=d,n.push(g)}else n.push(...t.connectors);let r;try{r=await((l=t.storage)==null?void 0:l.getItem("recentConnectorId"))}catch{}const s={};for(const[,d]of t.state.connections)s[d.connector.id]=1;r&&(s[r]=0);const o=Object.keys(s).length>0?[...n].sort((d,g)=>(s[d.id]??10)-(s[g.id]??10)):n;let i=!1;const c=[],a=[];for(const d of o){const g=await d.getProvider().catch(()=>{});if(!g||a.some(f=>f===g)||!await d.isAuthorized())continue;const w=await d.connect({isReconnecting:!0}).catch(()=>null);w&&(d.emitter.off("connect",t._internal.events.connect),d.emitter.on("change",t._internal.events.change),d.emitter.on("disconnect",t._internal.events.disconnect),t.setState(f=>{const h=new Map(i?f.connections:new Map).set(d.uid,{accounts:w.accounts,chainId:w.chainId,connector:d});return{...f,current:i?f.current:d.uid,connections:h}}),c.push({accounts:w.accounts,chainId:w.chainId,connector:d}),a.push(g),i=!0)}return(t.state.status==="reconnecting"||t.state.status==="connecting")&&(i?t.setState(d=>({...d,status:"connected"})):t.setState(d=>({...d,connections:new Map,current:null,status:"disconnected"}))),me=!1,c}async function wc(t,e){const{account:n,chainId:r,connector:s,gas:o,...i}=e;let c;typeof n=="object"&&n.type==="local"?c=t.getClient({chainId:r}):c=await it(t,{account:n,chainId:r,connector:s});const{connector:a}=ie(t),u=await(async()=>{var g;if(!(!("data"in e)||!e.data)&&!((g=s??a)!=null&&g.supportsSimulation)&&o!==null)return o===void 0?T(c,Yt,"estimateGas")({...i,account:n,chain:r?{id:r}:null}):o})();return await T(c,Re,"sendTransaction")({...i,...n?{account:n}:{},gas:u,chain:r?{id:r}:null})}async function bc(t,e){const{account:n,connector:r,...s}=e;let o;return typeof n=="object"&&n.type==="local"?o=t.getClient():o=await it(t,{account:n,connector:r}),T(o,Gn,"signMessage")({...s,...n?{account:n}:{}})}async function vc(t,e){const{account:n,connector:r,...s}=e;let o;return typeof n=="object"&&n.type==="local"?o=t.getClient():o=await it(t,{account:n,connector:r}),T(o,Fr,"signTypedData")({...s,...n?{account:n}:{}})}async function pi(t,e){const{abi:n,chainId:r,connector:s,...o}=e;let i;e.account?i=e.account:i=(await it(t,{chainId:r,connector:s})).account;const c=t.getClient({chainId:r}),a=T(c,Jn,"simulateContract"),{result:u,request:l}=await a({...o,abi:n,account:i});return{chainId:c.chain.id,result:u,request:{__mode:"prepared",...l,chainId:r}}}async function Cc(t,e){var s;const{connector:n}=e,r=t.state.connections.get(n.uid);if(!r)throw new We;return await((s=t.storage)==null?void 0:s.setItem("recentConnectorId",n.id)),t.setState(o=>({...o,current:n.uid})),{accounts:r.accounts,chainId:r.chainId}}class wt extends Y{constructor(){super("Provider not found."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ProviderNotFoundError"})}}class yi extends Y{constructor({connector:e}){super(`"${e.name}" does not support programmatic chain switching.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"SwitchChainNotSupportedError"})}}async function Ic(t,e){var i;const{addEthereumChainParameter:n,chainId:r}=e,s=t.state.connections.get(((i=e.connector)==null?void 0:i.uid)??t.state.current);if(s){const c=s.connector;if(!c.switchChain)throw new yi({connector:c});return await c.switchChain({addEthereumChainParameter:n,chainId:r})}const o=t.chains.find(c=>c.id===r);if(!o)throw new At;return t.setState(c=>({...c,chainId:r})),o}async function Ec(t,e){const{chainId:n,...r}=e,s=t.getClient({chainId:n});return T(s,kr,"verifyMessage")(r)}async function Sc(t,e){const{chainId:n,...r}=e,s=t.getClient({chainId:n});return T(s,Nr,"verifyTypedData")(r)}function Bc(t,e){const{onChange:n}=e;return t.subscribe(()=>ie(t),n,{equalityFn(r,s){const{connector:o,...i}=r,{connector:c,...a}=s;return ht(i,a)&&(o==null?void 0:o.id)===(c==null?void 0:c.id)&&(o==null?void 0:o.uid)===(c==null?void 0:c.uid)}})}function _c(t,e){const{syncConnectedChain:n=t._internal.syncConnectedChain,...r}=e;let s;const o=a=>{s&&s();const u=t.getClient({chainId:a});return s=T(u,Pr,"watchBlocks")(r),s},i=o(e.chainId);let c;return n&&!e.chainId&&(c=t.subscribe(({chainId:a})=>a,async a=>o(a))),()=>{i==null||i(),c==null||c()}}function xc(t,e){const{syncConnectedChain:n=t._internal.syncConnectedChain,...r}=e;let s;const o=a=>{s&&s();const u=t.getClient({chainId:a});return s=T(u,Tn,"watchBlockNumber")(r),s},i=o(e.chainId);let c;return n&&!e.chainId&&(c=t.subscribe(({chainId:a})=>a,async a=>o(a))),()=>{i==null||i(),c==null||c()}}function Ac(t,e){const{onChange:n}=e;return t.subscribe(r=>r.chainId,n)}function Tc(t,e){const{onChange:n}=e;return t.subscribe(()=>Dr(t),n,{equalityFn(r,s){return(r==null?void 0:r.uid)===(s==null?void 0:s.uid)}})}function kc(t,e){const{onChange:n}=e;return t.subscribe(()=>fi(t),n,{equalityFn:ht})}function Nc(t,e){const{onChange:n}=e;return t._internal.connectors.subscribe((r,s)=>{n(Object.values(r),s)})}function Pc(t,e){const{syncConnectedChain:n=t._internal.syncConnectedChain,...r}=e;let s;const o=a=>{s&&s();const u=t.getClient({chainId:a});return s=T(u,Xn,"watchContractEvent")(r),s},i=o(e.chainId);let c;return n&&!e.chainId&&(c=t.subscribe(({chainId:a})=>a,async a=>o(a))),()=>{i==null||i(),c==null||c()}}function qc(t,e){const{syncConnectedChain:n=t._internal.syncConnectedChain,...r}=e;let s;const o=a=>{s&&s();const u=t.getClient({chainId:a});return s=T(u,qr,"watchPendingTransactions")(r),s},i=o(e.chainId);let c;return n&&!e.chainId&&(c=t.subscribe(({chainId:a})=>a,async a=>o(a))),()=>{i==null||i(),c==null||c()}}function $c(t,e){const{onChange:n}=e;return t.subscribe(()=>hi(t),n,{equalityFn(r,s){return(r==null?void 0:r.uid)===(s==null?void 0:s.uid)}})}async function Fc(t,e){const{chainId:n,timeout:r=0,...s}=e,o=t.getClient({chainId:n}),c=await T(o,kn,"waitForTransactionReceipt")({...s,timeout:r});if(c.status==="reverted"){const u=await T(o,te,"getTransaction")({hash:c.transactionHash}),d=await T(o,Pt,"call")({...u,gasPrice:u.type!=="eip1559"?u.gasPrice:void 0,maxFeePerGas:u.type==="eip1559"?u.maxFeePerGas:void 0,maxPriorityFeePerGas:u.type==="eip1559"?u.maxPriorityFeePerGas:void 0}),g=d!=null&&d.data?Gt(`0x${d.data.substring(138)}`):"unknown reason";throw new Error(g)}return{...c,chainId:o.chain.id}}async function Rc(t,e){const{account:n,chainId:r,connector:s,__mode:o,...i}=e;let c;typeof n=="object"&&n.type==="local"?c=t.getClient({chainId:r}):c=await it(t,{account:n,chainId:r,connector:s});const{connector:a}=ie(t);let u;if(o==="prepared"||a!=null&&a.supportsSimulation)u=i;else{const{request:g}=await pi(t,{...i,account:n,chainId:r});u=g}return await T(c,zn,"writeContract")({...u,...n?{account:n}:{},chain:r?{id:r}:null})}function Oc(t){return t}const mi=/(rabby|trustwallet)/,wi={coinbaseWallet:{id:"coinbaseWallet",name:"Coinbase Wallet",provider(t){return t!=null&&t.coinbaseWalletExtension?t.coinbaseWalletExtension:Ht(t,"isCoinbaseWallet")}},metaMask:{id:"metaMask",name:"MetaMask",provider(t){return Ht(t,e=>{if(!e.isMetaMask||e.isBraveWallet&&!e._events&&!e._state)return!1;const n=["isApexWallet","isAvalanche","isBitKeep","isBlockWallet","isKuCoinWallet","isMathWallet","isOkxWallet","isOKExWallet","isOneInchIOSWallet","isOneInchAndroidWallet","isOpera","isPortal","isRabby","isTokenPocket","isTokenary","isZerion"];for(const r of n)if(e[r])return!1;return!0})}},phantom:{id:"phantom",name:"Phantom",provider(t){var e,n;return(e=t==null?void 0:t.phantom)!=null&&e.ethereum?(n=t.phantom)==null?void 0:n.ethereum:Ht(t,"isPhantom")}}};Ze.type="injected";function Ze(t={}){const{shimDisconnect:e=!0,unstable_shimAsyncInject:n}=t;function r(){const a=t.target;if(typeof a=="function"){const u=a();if(u)return u}return typeof a=="object"?a:typeof a=="string"?{...wi[a]??{id:a,name:`${a[0].toUpperCase()}${a.slice(1)}`,provider:`is${a[0].toUpperCase()}${a.slice(1)}`}}:{id:"injected",name:"Injected",provider(u){return u==null?void 0:u.ethereum}}}let s,o,i,c;return a=>({get icon(){return r().icon},get id(){return r().id},get name(){return r().name},get supportsSimulation(){return mi.test(this.id.toLowerCase())},type:Ze.type,async setup(){const u=await this.getProvider();u&&t.target&&(i||(i=this.onConnect.bind(this),u.on("connect",i)),s||(s=this.onAccountsChanged.bind(this),u.on("accountsChanged",s)))},async connect({chainId:u,isReconnecting:l}={}){var I,w,f,h,p,y;const d=await this.getProvider();if(!d)throw new wt;let g=[];if(l)g=await this.getAccounts().catch(()=>[]);else if(e)try{g=(h=(f=(w=(I=(await d.request({method:"wallet_requestPermissions",params:[{eth_accounts:{}}]}))[0])==null?void 0:I.caveats)==null?void 0:w[0])==null?void 0:f.value)==null?void 0:h.map(m=>tt(m))}catch(v){const m=v;if(m.code===U.code)throw new U(m);if(m.code===ae.code)throw m}try{!(g!=null&&g.length)&&!l&&(g=(await d.request({method:"eth_requestAccounts"})).map(C=>tt(C))),i&&(d.removeListener("connect",i),i=void 0),s||(s=this.onAccountsChanged.bind(this),d.on("accountsChanged",s)),o||(o=this.onChainChanged.bind(this),d.on("chainChanged",o)),c||(c=this.onDisconnect.bind(this),d.on("disconnect",c));let v=await this.getChainId();if(u&&v!==u){const m=await this.switchChain({chainId:u}).catch(C=>{if(C.code===U.code)throw C;return{id:v}});v=(m==null?void 0:m.id)??v}return e&&await((p=a.storage)==null?void 0:p.removeItem(`${this.id}.disconnected`)),t.target||await((y=a.storage)==null?void 0:y.setItem("injected.connected",!0)),{accounts:g,chainId:v}}catch(v){const m=v;throw m.code===U.code?new U(m):m.code===ae.code?new ae(m):m}},async disconnect(){var l,d;const u=await this.getProvider();if(!u)throw new wt;o&&(u.removeListener("chainChanged",o),o=void 0),c&&(u.removeListener("disconnect",c),c=void 0),i||(i=this.onConnect.bind(this),u.on("connect",i));try{await qe(()=>u.request({method:"wallet_revokePermissions",params:[{eth_accounts:{}}]}),{timeout:100})}catch{}e&&await((l=a.storage)==null?void 0:l.setItem(`${this.id}.disconnected`,!0)),t.target||await((d=a.storage)==null?void 0:d.removeItem("injected.connected"))},async getAccounts(){const u=await this.getProvider();if(!u)throw new wt;return(await u.request({method:"eth_accounts"})).map(d=>tt(d))},async getChainId(){const u=await this.getProvider();if(!u)throw new wt;const l=await u.request({method:"eth_chainId"});return Number(l)},async getProvider(){if(typeof window>"u")return;let u;const l=r();return typeof l.provider=="function"?u=l.provider(window):typeof l.provider=="string"?u=Ht(window,l.provider):u=l.provider,u&&!u.removeListener&&("off"in u&&typeof u.off=="function"?u.removeListener=u.off:u.removeListener=()=>{}),u},async isAuthorized(){var u,l;try{if(e&&await((u=a.storage)==null?void 0:u.getItem(`${this.id}.disconnected`))||!t.target&&!await((l=a.storage)==null?void 0:l.getItem("injected.connected")))return!1;if(!await this.getProvider()){if(n!==void 0&&n!==!1){const w=async()=>(typeof window<"u"&&window.removeEventListener("ethereum#initialized",w),!!await this.getProvider()),f=typeof n=="number"?n:1e3;if(await Promise.race([...typeof window<"u"?[new Promise(p=>window.addEventListener("ethereum#initialized",()=>p(w()),{once:!0}))]:[],new Promise(p=>setTimeout(()=>p(w()),f))]))return!0}throw new wt}return!!(await Vn(()=>this.getAccounts())).length}catch{return!1}},async switchChain({addEthereumChainParameter:u,chainId:l}){var I,w,f,h;const d=await this.getProvider();if(!d)throw new wt;const g=a.chains.find(p=>p.id===l);if(!g)throw new Ee(new At);try{return await Promise.all([d.request({method:"wallet_switchEthereumChain",params:[{chainId:D(l)}]}).then(async()=>{await this.getChainId()===l&&a.emitter.emit("change",{chainId:l})}),new Promise(p=>a.emitter.once("change",({chainId:y})=>{y===l&&p()}))]),g}catch(p){const y=p;if(y.code===4902||((w=(I=y==null?void 0:y.data)==null?void 0:I.originalError)==null?void 0:w.code)===4902)try{const{default:v,...m}=g.blockExplorers??{};let C;u!=null&&u.blockExplorerUrls?C=u.blockExplorerUrls:v&&(C=[v.url,...Object.values(m).map(A=>A.url)]);let b;(f=u==null?void 0:u.rpcUrls)!=null&&f.length?b=u.rpcUrls:b=[((h=g.rpcUrls.default)==null?void 0:h.http[0])??""];const E={blockExplorerUrls:C,chainId:D(l),chainName:(u==null?void 0:u.chainName)??g.name,iconUrls:u==null?void 0:u.iconUrls,nativeCurrency:(u==null?void 0:u.nativeCurrency)??g.nativeCurrency,rpcUrls:b};if(await d.request({method:"wallet_addEthereumChain",params:[E]}),await this.getChainId()!==l)throw new U(new Error("User rejected switch after adding network."));return g}catch(v){throw new U(v)}throw y.code===U.code?new U(y):new Ee(y)}},async onAccountsChanged(u){var l;if(u.length===0)this.onDisconnect();else if(a.emitter.listenerCount("connect")){const d=(await this.getChainId()).toString();this.onConnect({chainId:d}),e&&await((l=a.storage)==null?void 0:l.removeItem(`${this.id}.disconnected`))}else a.emitter.emit("change",{accounts:u.map(d=>tt(d))})},onChainChanged(u){const l=Number(u);a.emitter.emit("change",{chainId:l})},async onConnect(u){const l=await this.getAccounts();if(l.length===0)return;const d=Number(u.chainId);a.emitter.emit("connect",{accounts:l,chainId:d});const g=await this.getProvider();g&&(i&&(g.removeListener("connect",i),i=void 0),s||(s=this.onAccountsChanged.bind(this),g.on("accountsChanged",s)),o||(o=this.onChainChanged.bind(this),g.on("chainChanged",o)),c||(c=this.onDisconnect.bind(this),g.on("disconnect",c)))},async onDisconnect(u){const l=await this.getProvider();u&&u.code===1013&&l&&(await this.getAccounts()).length||(a.emitter.emit("disconnect"),l&&(o&&(l.removeListener("chainChanged",o),o=void 0),c&&(l.removeListener("disconnect",c),c=void 0),i||(i=this.onConnect.bind(this),l.on("connect",i))))}})}function Ht(t,e){function n(s){return typeof e=="function"?e(s):typeof e=="string"?s[e]:!0}const r=t.ethereum;if(r!=null&&r.providers)return r.providers.find(s=>n(s));if(r&&n(r))return r}Lr.type="mock";function Lr(t){const e=new Map,n=t.features??{};let r=!1,s;return o=>({id:"mock",name:"Mock Connector",type:Lr.type,async setup(){s=o.chains[0].id},async connect({chainId:i}={}){if(n.connectError)throw typeof n.connectError=="boolean"?new U(new Error("Failed to connect.")):n.connectError;const a=await(await this.getProvider()).request({method:"eth_requestAccounts"});let u=await this.getChainId();return i&&u!==i&&(u=(await this.switchChain({chainId:i})).id),r=!0,{accounts:a.map(l=>tt(l)),chainId:u}},async disconnect(){r=!1},async getAccounts(){if(!r)throw new We;return(await(await this.getProvider()).request({method:"eth_accounts"})).map(a=>tt(a))},async getChainId(){const c=await(await this.getProvider()).request({method:"eth_chainId"});return Qe(c,"number")},async isAuthorized(){return!n.reconnect||!r?!1:!!(await this.getAccounts()).length},async switchChain({chainId:i}){const c=await this.getProvider(),a=o.chains.find(u=>u.id===i);if(!a)throw new Ee(new At);return await c.request({method:"wallet_switchEthereumChain",params:[{chainId:D(i)}]}),a},onAccountsChanged(i){i.length===0?this.onDisconnect():o.emitter.emit("change",{accounts:i.map(c=>tt(c))})},onChainChanged(i){const c=Number(i);o.emitter.emit("change",{chainId:c})},async onDisconnect(i){o.emitter.emit("disconnect"),r=!1},async getProvider({chainId:i}={}){const a=(o.chains.find(l=>l.id===i)??o.chains[0]).rpcUrls.default.http[0];return Zn({request:async({method:l,params:d})=>{if(l==="eth_chainId")return D(s);if(l==="eth_requestAccounts")return t.accounts;if(l==="eth_signTypedData_v4"&&n.signTypedDataError)throw typeof n.signTypedDataError=="boolean"?new U(new Error("Failed to sign typed data.")):n.signTypedDataError;if(l==="wallet_switchEthereumChain"){if(n.switchChainError)throw typeof n.switchChainError=="boolean"?new U(new Error("Failed to switch chain.")):n.switchChainError;s=Qe(d[0].chainId,"number"),this.onChainChanged(s.toString());return}if(l==="wallet_getCapabilities")return{"0x2105":{paymasterService:{supported:d[0]==="0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266"},sessionKeys:{supported:!0}},"0x14A34":{paymasterService:{supported:d[0]==="0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266"}}};if(l==="wallet_sendCalls"){const f=[],h=d[0].calls;for(const y of h){const{result:v,error:m}=await de.http(a,{body:{method:"eth_sendTransaction",params:[y]}});if(m)throw new Lt({body:{method:l,params:d},error:m,url:a});f.push(v)}const p=X(ve(JSON.stringify(h)));return e.set(p,f),p}if(l==="wallet_getCallsStatus"){const f=e.get(d[0]);if(!f)return null;const h=await Promise.all(f.map(async p=>{const{result:y,error:v}=await de.http(a,{body:{method:"eth_getTransactionReceipt",params:[p],id:0}});if(v)throw new Lt({body:{method:l,params:d},error:v,url:a});return y?{blockHash:y.blockHash,blockNumber:y.blockNumber,gasUsed:y.gasUsed,logs:y.logs,status:y.status,transactionHash:y.transactionHash}:null}));return h.some(p=>!p)?{status:"PENDING",receipts:[]}:{status:"CONFIRMED",receipts:h}}if(l==="wallet_showCallsStatus")return;if(l==="personal_sign"){if(n.signMessageError)throw typeof n.signMessageError=="boolean"?new U(new Error("Failed to sign message.")):n.signMessageError;l="eth_sign",d=[d[1],d[0]]}const g={method:l,params:d},{error:I,result:w}=await de.http(a,{body:g});if(I)throw new Lt({body:g,error:I,url:a});return w}})({retryCount:0})}})}function bi(t){const e=n=>t(n.detail);return window.addEventListener("eip6963:announceProvider",e),window.dispatchEvent(new CustomEvent("eip6963:requestProvider")),()=>window.removeEventListener("eip6963:announceProvider",e)}function vi(){const t=new Set;let e=[];const n=()=>bi(s=>{e.some(({info:o})=>o.uuid===s.info.uuid)||(e=[...e,s],t.forEach(o=>o(e,{added:[s]})))});let r=n();return{_listeners(){return t},clear(){t.forEach(s=>s([],{removed:[...e]})),e=[]},destroy(){this.clear(),t.clear(),r()},findProvider({rdns:s}){return e.find(o=>o.info.rdns===s)},getProviders(){return e},reset(){this.clear(),r(),r=n()},subscribe(s,{emitImmediately:o}={}){return t.add(s),o&&s(e,{added:e}),()=>t.delete(s)}}}const Ci={},Ii=t=>(e,n,r)=>{const s=r.subscribe;return r.subscribe=(i,c,a)=>{let u=i;if(c){const l=(a==null?void 0:a.equalityFn)||Object.is;let d=i(r.getState());u=g=>{const I=i(g);if(!l(d,I)){const w=d;c(d=I,w)}},a!=null&&a.fireImmediately&&c(d,d)}return s(u)},t(e,n,r)},Ei=Ii;function Si(t,e){let n;try{n=t()}catch{return}return{getItem:s=>{var o;const i=a=>a===null?null:JSON.parse(a,void 0),c=(o=n.getItem(s))!=null?o:null;return c instanceof Promise?c.then(i):i(c)},setItem:(s,o)=>n.setItem(s,JSON.stringify(o,void 0)),removeItem:s=>n.removeItem(s)}}const kt=t=>e=>{try{const n=t(e);return n instanceof Promise?n:{then(r){return kt(r)(n)},catch(r){return this}}}catch(n){return{then(r){return this},catch(r){return kt(r)(n)}}}},Bi=(t,e)=>(n,r,s)=>{let o={getStorage:()=>localStorage,serialize:JSON.stringify,deserialize:JSON.parse,partialize:h=>h,version:0,merge:(h,p)=>({...p,...h}),...e},i=!1;const c=new Set,a=new Set;let u;try{u=o.getStorage()}catch{}if(!u)return t((...h)=>{console.warn(`[zustand persist middleware] Unable to update item '${o.name}', the given storage is currently unavailable.`),n(...h)},r,s);const l=kt(o.serialize),d=()=>{const h=o.partialize({...r()});let p;const y=l({state:h,version:o.version}).then(v=>u.setItem(o.name,v)).catch(v=>{p=v});if(p)throw p;return y},g=s.setState;s.setState=(h,p)=>{g(h,p),d()};const I=t((...h)=>{n(...h),d()},r,s);let w;const f=()=>{var h;if(!u)return;i=!1,c.forEach(y=>y(r()));const p=((h=o.onRehydrateStorage)==null?void 0:h.call(o,r()))||void 0;return kt(u.getItem.bind(u))(o.name).then(y=>{if(y)return o.deserialize(y)}).then(y=>{if(y)if(typeof y.version=="number"&&y.version!==o.version){if(o.migrate)return o.migrate(y.state,y.version);console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return y.state}).then(y=>{var v;return w=o.merge(y,(v=r())!=null?v:I),n(w,!0),d()}).then(()=>{p==null||p(w,void 0),i=!0,a.forEach(y=>y(w))}).catch(y=>{p==null||p(void 0,y)})};return s.persist={setOptions:h=>{o={...o,...h},h.getStorage&&(u=h.getStorage())},clearStorage:()=>{u==null||u.removeItem(o.name)},getOptions:()=>o,rehydrate:()=>f(),hasHydrated:()=>i,onHydrate:h=>(c.add(h),()=>{c.delete(h)}),onFinishHydration:h=>(a.add(h),()=>{a.delete(h)})},f(),w||I},_i=(t,e)=>(n,r,s)=>{let o={storage:Si(()=>localStorage),partialize:f=>f,version:0,merge:(f,h)=>({...h,...f}),...e},i=!1;const c=new Set,a=new Set;let u=o.storage;if(!u)return t((...f)=>{console.warn(`[zustand persist middleware] Unable to update item '${o.name}', the given storage is currently unavailable.`),n(...f)},r,s);const l=()=>{const f=o.partialize({...r()});return u.setItem(o.name,{state:f,version:o.version})},d=s.setState;s.setState=(f,h)=>{d(f,h),l()};const g=t((...f)=>{n(...f),l()},r,s);let I;const w=()=>{var f,h;if(!u)return;i=!1,c.forEach(y=>{var v;return y((v=r())!=null?v:g)});const p=((h=o.onRehydrateStorage)==null?void 0:h.call(o,(f=r())!=null?f:g))||void 0;return kt(u.getItem.bind(u))(o.name).then(y=>{if(y)if(typeof y.version=="number"&&y.version!==o.version){if(o.migrate)return o.migrate(y.state,y.version);console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return y.state}).then(y=>{var v;return I=o.merge(y,(v=r())!=null?v:g),n(I,!0),l()}).then(()=>{p==null||p(I,void 0),I=r(),i=!0,a.forEach(y=>y(I))}).catch(y=>{p==null||p(void 0,y)})};return s.persist={setOptions:f=>{o={...o,...f},f.storage&&(u=f.storage)},clearStorage:()=>{u==null||u.removeItem(o.name)},getOptions:()=>o,rehydrate:()=>w(),hasHydrated:()=>i,onHydrate:f=>(c.add(f),()=>{c.delete(f)}),onFinishHydration:f=>(a.add(f),()=>{a.delete(f)})},o.skipHydration||w(),I||g},xi=(t,e)=>"getStorage"in e||"serialize"in e||"deserialize"in e?((Ci?"production":void 0)!=="production"&&console.warn("[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead."),Bi(t,e)):_i(t,e),Ai=xi,Ti={},gn=t=>{let e;const n=new Set,r=(a,u)=>{const l=typeof a=="function"?a(e):a;if(!Object.is(l,e)){const d=e;e=u??typeof l!="object"?l:Object.assign({},e,l),n.forEach(g=>g(e,d))}},s=()=>e,c={setState:r,getState:s,subscribe:a=>(n.add(a),()=>n.delete(a)),destroy:()=>{(Ti?"production":void 0)!=="production"&&console.warn("[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."),n.clear()}};return e=t(r,s,c),c},we=t=>t?gn(t):gn;class ki{constructor(e){Object.defineProperty(this,"uid",{enumerable:!0,configurable:!0,writable:!0,value:e}),Object.defineProperty(this,"_emitter",{enumerable:!0,configurable:!0,writable:!0,value:new ws})}on(e,n){this._emitter.on(e,n)}once(e,n){this._emitter.once(e,n)}off(e,n){this._emitter.off(e,n)}emit(e,...n){const r=n[0];this._emitter.emit(e,{uid:this.uid,...r})}listenerCount(e){return this._emitter.listenerCount(e)}}function Ni(t){return new ki(t)}function Mr(t,e){return JSON.parse(t,(n,r)=>{let s=r;return(s==null?void 0:s.__type)==="bigint"&&(s=BigInt(s.value)),(s==null?void 0:s.__type)==="Map"&&(s=new Map(s.value)),(e==null?void 0:e(n,s))??s})}function pn(t,e){return t.slice(0,e).join(".")||"."}function yn(t,e){const{length:n}=t;for(let r=0;r<n;++r)if(t[r]===e)return r+1;return 0}function Pi(t,e){const n=typeof t=="function",r=typeof e=="function",s=[],o=[];return function(c,a){if(typeof a=="object")if(s.length){const u=yn(s,this);u===0?s[s.length]=this:(s.splice(u),o.splice(u)),o[o.length]=c;const l=yn(s,a);if(l!==0)return r?e.call(this,c,a,pn(o,l)):`[ref=${pn(o,l)}]`}else s[0]=a,o[0]=c;return n?t.call(this,c,a):a}}function qi(t,e,n,r){return JSON.stringify(t,Pi((s,o)=>{let i=o;return typeof i=="bigint"&&(i={__type:"bigint",value:o.toString()}),i instanceof Map&&(i={__type:"Map",value:Array.from(o.entries())}),(e==null?void 0:e(s,i))??i},r),n??void 0)}function $i(t){const{deserialize:e=Mr,key:n="wagmi",serialize:r=qi,storage:s=Ur}=t;function o(i){return i instanceof Promise?i.then(c=>c).catch(()=>null):i}return{...s,key:n,async getItem(i,c){const a=s.getItem(`${n}.${i}`),u=await o(a);return u?e(u)??null:c??null},async setItem(i,c){const a=`${n}.${i}`;c===null?await o(s.removeItem(a)):await o(s.setItem(a,r(c)))},async removeItem(i){await o(s.removeItem(`${n}.${i}`))}}}const Ur={getItem:()=>null,setItem:()=>{},removeItem:()=>{}},Te=256;let Ot=Te,Dt;function Fi(t=11){if(!Dt||Ot+t>Te*2){Dt="",Ot=0;for(let e=0;e<Te;e++)Dt+=(256+Math.random()*256|0).toString(16).substring(1)}return Dt.substring(Ot,Ot+++t)}function Dc(t){const{multiInjectedProviderDiscovery:e=!0,storage:n=$i({storage:typeof window<"u"&&window.localStorage?window.localStorage:Ur}),syncConnectedChain:r=!0,ssr:s,...o}=t,i=typeof window<"u"&&e?vi():void 0,c=we(()=>o.chains),a=we(()=>[...o.connectors??[],...s?[]:(i==null?void 0:i.getProviders().map(l))??[]].map(u));function u(m){var E;const C=Ni(Fi()),b={...m({emitter:C,chains:c.getState(),storage:n}),emitter:C,uid:C.uid};return C.on("connect",y),(E=b.setup)==null||E.call(b),b}function l(m){const{info:C}=m,b=m.provider;return Ze({target:{...C,id:C.rdns,provider:b}})}const d=new Map;function g(m={}){const C=m.chainId??h.getState().chainId,b=c.getState().find(S=>S.id===C);if(m.chainId&&!b)throw new At;{const S=d.get(h.getState().chainId);if(S&&!b)return S;if(!b)throw new At}{const S=d.get(C);if(S)return S}let E;if(o.client)E=o.client({chain:b});else{const S=b.id,A=c.getState().map(P=>P.id),k={},x=Object.entries(o);for(const[P,q]of x)if(!(P==="chains"||P==="client"||P==="connectors"||P==="transports"))if(typeof q=="object")if(S in q)k[P]=q[S];else{if(A.some(B=>B in q))continue;k[P]=q}else k[P]=q;E=Wn({...k,chain:b,batch:k.batch??{multicall:!0},transport:P=>o.transports[S]({...P,connectors:a})})}return d.set(C,E),E}function I(){return{chainId:c.getState()[0].id,connections:new Map,current:null,status:"disconnected"}}let w;const f="0.0.0-canary-";Ut.startsWith(f)?w=Number.parseInt(Ut.replace(f,"")):w=Number.parseInt(Ut.split(".")[0]??"0");const h=we(Ei(n?Ai(I,{migrate(m,C){if(C===w)return m;const b=I(),E=m&&typeof m=="object"&&"chainId"in m&&typeof m.chainId=="number"&&c.getState().some(S=>S.id===m.chainId)?m.chainId:b.chainId;return{...b,chainId:E}},name:"store",partialize(m){return{connections:{__type:"Map",value:Array.from(m.connections.entries()).map(([C,b])=>{const{id:E,name:S,type:A,uid:k}=b.connector;return[C,{...b,connector:{id:E,name:S,type:A,uid:k}}]})},chainId:m.chainId,current:m.current}},skipHydration:s,storage:n,version:w}):I));r&&h.subscribe(({connections:m,current:C})=>{var b;return C?(b=m.get(C))==null?void 0:b.chainId:void 0},m=>{if(c.getState().some(b=>b.id===m))return h.setState(b=>({...b,chainId:m??b.chainId}))}),i==null||i.subscribe(m=>{const C=new Map;for(const E of a.getState())C.set(E.id,!0);const b=[];for(const E of m){const S=u(l(E));C.has(S.id)||b.push(S)}n&&!h.persist.hasHydrated()||a.setState(E=>[...E,...b],!0)});function p(m){h.setState(C=>{const b=C.connections.get(m.uid);return b?{...C,connections:new Map(C.connections).set(m.uid,{accounts:m.accounts??b.accounts,chainId:m.chainId??b.chainId,connector:b.connector})}:C})}function y(m){h.getState().status==="connecting"||h.getState().status==="reconnecting"||h.setState(C=>{const b=a.getState().find(E=>E.uid===m.uid);return b?(b.emitter.listenerCount("connect")&&b.emitter.off("connect",p),b.emitter.listenerCount("change")||b.emitter.on("change",p),b.emitter.listenerCount("disconnect")||b.emitter.on("disconnect",v),{...C,connections:new Map(C.connections).set(m.uid,{accounts:m.accounts,chainId:m.chainId,connector:b}),current:m.uid,status:"connected"}):C})}function v(m){h.setState(C=>{const b=C.connections.get(m.uid);if(b){const S=b.connector;S.emitter.listenerCount("change")&&b.connector.emitter.off("change",p),S.emitter.listenerCount("disconnect")&&b.connector.emitter.off("disconnect",v),S.emitter.listenerCount("connect")||b.connector.emitter.on("connect",y)}if(C.connections.delete(m.uid),C.connections.size===0)return{...C,connections:new Map,current:null,status:"disconnected"};const E=C.connections.values().next().value;return{...C,connections:new Map(C.connections),current:E.connector.uid}})}return{get chains(){return c.getState()},get connectors(){return a.getState()},storage:n,getClient:g,get state(){return h.getState()},setState(m){let C;typeof m=="function"?C=m(h.getState()):C=m;const b=I();typeof C!="object"&&(C=b),Object.keys(b).some(S=>!(S in C))&&(C=b),h.setState(C,!0)},subscribe(m,C,b){return h.subscribe(m,C,b?{...b,fireImmediately:b.emitImmediately}:void 0)},_internal:{mipd:i,store:h,ssr:!!s,syncConnectedChain:r,transports:o.transports,chains:{setState(m){const C=typeof m=="function"?m(c.getState()):m;if(C.length!==0)return c.setState(C,!0)},subscribe(m){return c.subscribe(m)}},connectors:{providerDetailToConnector:l,setup:u,setState(m){return a.setState(typeof m=="function"?m(a.getState()):m,!0)},subscribe(m){return a.subscribe(m)}},events:{change:p,connect:y,disconnect:v}}}}function Lc(t,e){const{initialState:n,reconnectOnMount:r}=e;return n&&!t._internal.store.persist.hasHydrated()&&t.setState({...n,chainId:t.chains.some(s=>s.id===n.chainId)?n.chainId:t.chains[0].id,connections:r?n.connections:new Map,status:r?"reconnecting":"disconnected"}),{async onMount(){var s;if(t._internal.ssr){await t._internal.store.persist.rehydrate();const o=(s=t._internal.mipd)==null?void 0:s.getProviders().map(t._internal.connectors.providerDetailToConnector).map(t._internal.connectors.setup);t._internal.connectors.setState(i=>[...i,...o??[]])}r?gi(t):t.storage&&t.setState(o=>({...o,connections:new Map}))}}}function Mc(t,e={}){const{type:n}=t,{key:r="connector",name:s="Connector",retryDelay:o}=e;return i=>{const{chain:c,connectors:a}=i,u=e.retryCount??i.retryCount;return ke({key:r,name:s,request:async({method:d,params:g})=>{const I=a==null?void 0:a.getState().find(p=>p.type===n);if(!I)throw new tn(new Error(`Could not find connector of type "${n}" in \`connectors\` passed to \`createConfig\`.`));const w=await I.getProvider({chainId:c==null?void 0:c.id});if(!w)throw new tn(new Error("Provider is disconnected."));const f=Pe(await Vn(()=>qe(()=>w.request({method:"eth_chainId"}),{timeout:100})));if(c&&f!==c.id)throw new bs(new Error(`The current chain of the connector (id: ${f}) does not match the target chain for the request (id: ${c.id}  ${c.name}).`));const h={method:d,params:g};return w.request(h)},retryCount:u,retryDelay:o,type:"connector"})}}function Uc(t,e){return As(t,e)}const Hc={getItem(t){return typeof window>"u"?null:Hr(document.cookie,t)??null},setItem(t,e){typeof window>"u"||(document.cookie=`${t}=${e};Path=/;SameSite=Lax`)},removeItem(t){typeof window>"u"||(document.cookie=`${t}=;max-age=-1`)}};function jc(t,e){var s;if(!e)return;const n=`${(s=t.storage)==null?void 0:s.key}.store`,r=Hr(e,n);if(r)return Mr(r).state}function Hr(t,e){const n=t.split("; ").find(r=>r.startsWith(`${e}=`));if(n)return n.substring(e.length+1)}function zc(t){if(typeof t=="string")return Number.parseInt(t,t.trim().substring(0,2)==="0x"?16:10);if(typeof t=="bigint")return Number(t);if(typeof t=="number")return t;throw new Error(`Cannot normalize chainId "${t}" of type "${typeof t}"`)}export{Y as BaseError,At as ChainNotConfiguredError,ai as ConnectorAccountNotFoundError,ci as ConnectorAlreadyConnectedError,ui as ConnectorChainMismatchError,We as ConnectorNotConnectedError,Ui as ConnectorNotFoundError,wt as ProviderNotFoundError,yi as SwitchChainNotSupportedError,Mi as call,Hi as connect,Hc as cookieStorage,jc as cookieToInitialState,Dc as createConfig,Oc as createConnector,$i as createStorage,Zn as custom,ht as deepEqual,ji as deployContract,Mr as deserialize,zi as disconnect,Wi as estimateFeesPerGas,Gi as estimateGas,Zi as estimateMaxPriorityFeePerGas,Uc as fallback,Vi as fetchBalance,Yi as fetchBlockNumber,nc as fetchEnsAddress,rc as fetchEnsAvatar,sc as fetchEnsName,oc as fetchEnsResolver,lc as fetchToken,fc as fetchTransaction,ie as getAccount,Vi as getBalance,Ki as getBlock,Yi as getBlockNumber,Ji as getBlockTransactionCount,Xi as getBytecode,Qi as getChainId,tc as getChains,Dr as getClient,fi as getConnections,it as getConnectorClient,ec as getConnectors,nc as getEnsAddress,rc as getEnsAvatar,sc as getEnsName,oc as getEnsResolver,ic as getEnsText,cc as getFeeHistory,ac as getGasPrice,uc as getProof,hi as getPublicClient,dc as getStorageAt,lc as getToken,fc as getTransaction,hc as getTransactionConfirmations,gc as getTransactionCount,pc as getTransactionReceipt,yc as getWalletClient,Zc as http,Lc as hydrate,Ze as injected,Lr as mock,di as multicall,Ur as noopStorage,zc as normalizeChainId,Hr as parseCookie,mc as prepareTransactionRequest,li as readContract,Ae as readContracts,gi as reconnect,wc as sendTransaction,qi as serialize,bc as signMessage,vc as signTypedData,pi as simulateContract,Cc as switchAccount,Ic as switchChain,Ic as switchNetwork,Mc as unstable_connector,Ec as verifyMessage,Sc as verifyTypedData,Ut as version,Fc as waitForTransaction,Fc as waitForTransactionReceipt,Bc as watchAccount,xc as watchBlockNumber,_c as watchBlocks,Ac as watchChainId,Tc as watchClient,kc as watchConnections,Nc as watchConnectors,Pc as watchContractEvent,qc as watchPendingTransactions,$c as watchPublicClient,Li as webSocket,Rc as writeContract};
